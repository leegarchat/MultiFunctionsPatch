#!/sbin/sh

#Объявление основых переменных и постоянных функций
export OUTFD=$2

arg1=$1 ; arg2=$2 ; arg3=$3



ui_print(){ echo -e "ui_print $1\nui_print" >> "/proc/self/fd/$arg2" ; }
calc(){ awk 'BEGIN{ print int('$1') }' ; }
tabes="
"
MFPAPP="MFP-4.1.11"
RUN_WRITE_LOG(){
	cp /system/etc/fstab $home/system_fstab.txt
	getprop >> $home/getprop.txt
	for block in $( find /dev/block/ ) ; do
		if ! [[ -d $block ]] ; then 
			if ( file $block | grep "symbolic link" ) ; then 
				linktoblock=$( readlink $block ) 
			else 
				linktoblock="" 
			fi
			echo "$block $( [[ -z $linktoblock ]] || echo "link -->> $linktoblock" )" >> $home/List_DevBlock.txt
		else
			continue
		fi
	done
	cp $arguments $home/
	cp /tmp/*.log $home/
	cp /tmp/*.txt $home/
	for listHome in $( find $home/ ) ; do
		if ! [[ -d $listHome ]] ; then
			echo "$listHome - size:$( stat -c%s $listHome )" >> $home/List_home.txt
		else
			continue
		fi
	done
	f=""
	for log in $( find $home/ -name "*.txt" ) $( find $home/ -name "*.log" ) ; do 
		f="$f $log"
	done
	[[ -d $zipfolder/MFPLOGS ]] || rm -rf $zipfolder/MFPLOGS
	mkdir $zipfolder/MFPLOGS
	tar -cvpf  $zipfolder/MFPLOGS/logs.tar $f
	ui_print "-  save log file to $zipfolder/MFPLOGS/logs.tar"
	}
RUN_ABORT(){
	RUN_ALL_MAUNT --umount
	RUN_MOUNT_SUPER --umount-super
	RUN_MOUNT_SUPER --umount-fw	
	for print in "$2" "$3" "$4" "$5" "$6" "$7" "$8" ; do
		! [[ -z $print ]] && ui_print "-  $print"
	done
	ui_print "-  Send $zipfolder/MFPLOGS/logs.tar file in group @PocoF3DFE or me PM @LeeGarChat"
	ui_print "-  Your installed system shouldn't have gone bad"
	ui_print "-  But the new system/patch is not installed"
	RUN_WRITE_LOG
	rm -rf $home
	exit $1
	}
RUN_READ_ARG(){
	for remove in $( grep "\"/storage/" $arguments ) ; do
		dod1=${remove#*\"} ; dod1=${dod1%\"*}
		dod2="/data/media/0/"${dod1#*/*/*/*/}""
		echo $remove | grep "\"/storage/" && sed -i 's|'$dod1'|'$dod2'|' $arguments
	done
	for remove in $( grep "\"/mnt/" $arguments ) ; do
		dod1=${remove#*\"} ; dod1=${dod1%\"*}
		dod2="/usb_otg/"${dod#*/*/*/*/}""
		echo $remove | grep "\"/mnt/" && sed -i 's|'$dod1'|'$dod2'|' $arguments
	done

	if ( grep "INSTALL SLOT" "$arguments" | grep -i "_a" ) ; then
		$flashrom && newslot="_a" || newslot="$slot_ab"
	elif ( grep "INSTALL SLOT" "$arguments" | grep -i "_b" ) ; then
		$flashrom && newslot="_b" || newslot="$slot_ab"
	else 
		newslot="$slot_ab" ; fi

	( grep "MAKERW" "$arguments" | grep -i "yes" ) && flashrw=true || flashrw=false

	( grep "HIDE NOT ENCRYPTED" "$arguments" | grep -i "yes" ) && hide_no_encrypted=true || hide_no_encrypted=false

	( grep "DFE" "$arguments" | grep -i "yes" ) && flashdfe=true || flashdfe=false

	( grep "WIPE DATA" "$arguments" | grep -i "yes" ) && wipedata=true || wipedata=false

	( grep "REMOVE MFPAPP FOLDER" "$arguments" | grep -i "yes" ) && delhome=true || delhome=false

	( grep "POST BOOT PATCH" "$arguments" | grep -i "yes" ) && boot_patch=true || boot_patch=false

	( grep "POST VENDORBOOT PATCH" "$arguments" | grep -i "yes" ) && vendor_boot_patch=true || vendor_boot_patch=false

	( grep "DISABLE VERIFICATION" "$arguments" | grep -i "yes" ) && DM_VERI=true || DM_VERI=false

	( grep "DISABLE VERITY" "$arguments" | grep -i "yes" ) && DM_VERY=true || DM_VERY=false

	( grep "FORCE 120HZ FOR ALL APPS" "$arguments" | grep -i "yes" ) && FORCE_FPS=true || FORCE_FPS=false

	( grep "FIX 120HZ & BRIGHTNESS" "$arguments" | grep -i "yes" ) && FIX_FPS=true || FIX_FPS=false 
	
	( grep "HOS TREE SKIP CHECK" "$arguments" | grep -i "yes" ) && sm8250skip=true || sm8250skip=false 


	# if ( grep "BOOT LOGO" "$arguments" ) ; then
	# 	line=$( grep "BOOT LOGO" "$arguments" )
	# 	line=${line#*\"} ; line=${line%\"*}
	# 	case $line in
	# 		mi|MI|Mi) flashlogo=true ; bootlogo=/tmp/bin/mi ;;
	# 		redmi|Redmi|REDMI) flashlogo=true ; bootlogo=/tmp/bin/redmi ;;
	# 		poco|Poco|POCO) flashlogo=true ; bootlogo=/tmp/bin/poco ;;
	# 		*) flashlogo=false ;;
	# 	esac
	# fi


	if ( grep "REBOOT AFTER" "$arguments" | grep -i "system" ) ; then
		rebootafter=true ; rebootARG=system
	elif ( grep "REBOOT AFTER" "$arguments" | grep -i "recovery" ) ; then
		rebootafter=true ; rebootARG=recovery
	elif ( grep "REBOOT AFTER" "$arguments" | grep -i "bootloader" ) ; then
		rebootafter=true ; rebootARG=bootloader 
	else rebootafter=false ; fi

	nlines=$( grep -n "FLASH CUSTOM IMGS" "$arguments" | awk '{print int($1)}' )
	flash_custom_img=false
	for line in $nlines ; do line=$(head -n$line "$arguments" | tail -n1)
		if ( echo ${line%FLASH CUSTOM IMGS*} | grep "#" ) ; then continue ; else
			imgC="${line#*\"}" ; imgC="${imgC%%\"*}"
			imgP="${line%\"*}" ; imgP="${imgP##*\"}"
			if [[ -z $imgC ]] || [[ -z $imgP ]] ; then continue ; else
				if ( echo $imgC | grep "/" ) && [[ -f $imgC ]] ; then 
					FimgC=$imgC
				elif ! ( echo $imgC | grep "/" ) && [[ -f $zipfolder/$imgC ]] ; then
					FimgC=$zipfolder/$imgC
				else RUN_ABORT "32" "NOT FIND $imgC" "You have entered the wrong file path." ; fi
				case $imgP in
				system|vendor|odm|product|system_ext) echo "${Fimg}FLASHTOFLASH$imgP$newslot" >> $home/custom_imgs_for_super.txt ;;
												   *)	
				if ( find /dev/block/by-name/ -name "$imgP$newslot" ) ; then
					flash_custom_img=true
					echo "${FimgC}FLASHTOFLASH$imgP" >> $home/custom_imgs_for_fw.txt 
				elif ( find /dev/block/by-name/ -name "$imgP" ) ; then
					flash_custom_img=true
					echo "${FimgC}FLASHTOFLASH$imgP" >> $home/custom_imgs_for_fw.txt ; fi
						;;
	esac ; fi ; fi ; done

	nlines=$( grep -n "FLASH ROM" "$arguments" | awk '{print int($1)}' )
	flashrom=false ;
	for lines in $nlines ; do 
		line=$(head -n$lines "$arguments" | tail -n1)
		if ( echo ${line%FLASH ROM*} | grep "#" ) ; then 
			continue 
		else
			name_rom=${line#*\"}
			name_rom=${name_rom%\"*} 
			if [[ -z $name_rom ]] ; then 
				flashrom=false 
			else
				if ( echo $name_rom | grep "/" ) ; then 
					romzip=$name_rom
				else 
					romzip="$zipfolder/$name_rom" 
				fi
				if [[ -f $romzip ]] ; then 
					$flashrom && RUN_ABORT "35" " "\
					"You specified more than one ROM, \
					remove the unnecessary install ROM from \
					arguments.txt or comment it out with #" " "
					flashrom=true
				else 
					RUN_ABORT "5" "Not find $romzip" "You have entered the wrong file path."
				fi
			fi 
		fi
	done

	nlines=$(grep -n "FLASH ADDITIONAL ZIPS" "$arguments" | awk '{print int($1)}')
	for line in $nlines ; do
		list=$(head -n$line "$arguments" | tail -n1)
		list=$( echo "$list" | grep -q "\.zip" && echo $list ; echo "$list" | grep -q "\.apk" && echo $list ) 
		name_ADDzip=${list#*\"} ; name_ADDzip=${name_ADDzip%\"*}
		if ( echo ${list%Path additional zips*} | grep '#' ) ; then 
			continue
		else
			if [[ -z $name_ADDzip ]] ; then 
				continue 
			else
				if ( echo $name_ADDzip | grep "/" ) ; then 
					ADDzip=$name_ADDzip
				else 
					ADDzip="$zipfolder/$name_ADDzip" 
				fi
				if [[ -f $ADDzip ]] ; then 
					listADDzip="$listADDzip\n$ADDzip"
				else
					RUN_ABORT "6" "Not find $ADDzip" "You have entered the wrong file path."
				fi 
			fi
		fi
	done
	
	if ( echo -e "$listADDzip" | grep "/" ) ; then flashADDzip=true ; else flashADDzip=false ; fi



	nlines=$( grep -n "FLASH RECOVERY" "$arguments" | awk '{print int($1)}' )
	flashrec=false ;
	for lines in $nlines ; do 
		line=$(head -n$lines "$arguments" | tail -n1)
		if ( echo ${line%FLASH RECOVERY*} | grep "#" ) ; then 
			continue 
		else
			name_rec=${line#*\"}
			name_rec=${name_rec%\"*} 
			if [[ -z $name_rec ]] ; then 
				flashrec=false 
			else
				if ( echo $name_rec | grep "/" ) ; then 
					reczip=$name_rec
				else 
					reczip="$zipfolder/$name_rec" 
				fi
				if [[ -f $reczip ]] ; then 
					$flashrec && RUN_ABORT "77" " "\
					"You specified more than one RECOVERY, \
					remove the unnecessary install RECOVERY from \
					arguments.txt or comment it out with #" " "
					flashrec=true
				else 
					RUN_ABORT "77" "Not find $reczip" "You have entered the wrong file path."
				fi
			fi 
		fi
	done
	
	if ( grep "RECOVERY REFLASH" "$arguments" | grep -i "yes" ) ; then 
		if $flashrom ; then  
			reflashrec=true
			RUN_ALL_MAUNT --umount
			if ( sha256sum --status -c /ramdisk-files.sha256sum ) || ( sha256sum --status -c /ramdisk-files.checkmus ) ; then 
				mkdir -pv /tmp/bin/twrp/
				cpio -H newc -o < /ramdisk-files.txt > /tmp/bin/twrp/ramdisk.cpio
			else
				RUN_ABORT "8" "Ramdisk files have been modified, unable" \
				"to create ramdisk to flash, fastboot boot twrp or reboot" \
				"twrp and try again flash mfp with options RECOVERY REFLASH" 
			fi
		else reflashrec=false
		fi
	else reflashrec=false ; fi

	}
RUN_ARG_CHECK(){ 
	if ! $flashrom && ! $flashrec && ! $flashdfe && ! $flashrw && ! $flashADDzip && ! $flash_custom_img ; then 
		RUN_ABORT "9" "No arguments" "Copy .zip name in arguments.txt into .zip files or creat near .zip arguments.txt and rename fmp to ARGOUT-MFP.zip"
	else
		RUN_LOGO
	fi
	}
RUN_LOGO(){
	ui_print "------******!!!!!!!!!!!!!!!!!!!!******-------"
	ui_print "-  Home folder $home"

	ui_print "------******!!!!!!!!!!!!!!!!!!!!******-------"
	ui_print " "
	ui_print "-  $MFPAPP"
	ui_print "-  by @LeeGarChat"
	ui_print "-  Group @PocoF3DFE"
	ui_print "-  Thanks for @ErenMetesarr"
	ui_print " "
	ui_print "------******!!!!!!!!!!!!!!!!!!!!******-------"
	ui_print " "
	$flashrw && ui_print "-  MAKERW: $( $flashrw && echo "YES" || echo NO )"
	$flashdfe && ui_print "-  DFE: $( $flashdfe && echo "YES" || echo NO )"
	ui_print "-  INSLOT-A/B: $newslot"
	$reflashrec && ui_print "-  REFLASH RECOVERY: $( $reflashrec && echo "YES" || echo NO )"
	$flashrec && ui_print "-  FLASH RECOVERY: $( $flashrec && echo "YES" || echo NO )"
	$flashrom && ui_print "-  FLASH ROM: $( $flashrom && echo "YES" || echo NO )"
	$flashADDzip && ui_print "-  ADDITIONAL ZIPS: $( $flashADDzip && echo "YES" || echo "NO" )"
	$wipedata && ui_print "-  WIPE DATA AFTER FLASHING: $( $wipedata && echo "YES" || echo "NO" )"
	$delhome && ui_print "-  REMOVE MFPAPP FOLDER AFTER FLASHING: $( $delhome && echo "YES" || echo "NO" )"
	$rebootafter && ui_print "-  REBOOT AFTER FLASHING: $( $rebootafter && echo "YES : $rebootARG" || echo "NO" )"
	$hide_no_encrypted && ui_print "-  HIDE NOT ENCRYPTED: $( $hide_no_encrypted && echo "YES" || echo "NO" )"
	$DM_VERI && ui_print "-  DISABLE VERIFICATION: $( $DM_VERI && echo "YES" || echo "NO" )"
	$DM_VERY && ui_print "-  DISABLE VERITY: $( $DM_VERY && echo "YES" || echo "NO" )"
	$boot_patch && ui_print "-  BOOT PATCH: $( $boot_patch && echo "YES" || echo "NO" )"
	$vendor_boot_patch && ui_print "-  VENDOR BOOT PATCH: $( $vendor_boot_patch && echo "YES" || echo "NO" )"
	$flash_custom_img && ui_print "-  FLASH CUSTOM IMG: $( $flash_custom_img && echo "YES" || echo "NO" )"
	$FIX_FPS && ui_print "-  FIX 120HZ: YES"
	$FORCE_FPS && ui_print "-  FORCE 120HZ FOR ALL APPS: YES"
	#$flashlogo && ui_print "-  FLASH LOGO: ${bootlogo#*/tmp/bin/}"


	if ! $flashADDzip && ! $flashrom && ! $flashrec ; then 
		ui_print " "
		ui_print "------******!!!!!!!!!!!!!!!!!!!!******-------" ; fi
	if $flashrom ; then
		ui_print " "
	ui_print "------******!!!!!!!!ROM!!!!!!!!!******-------"
	ui_print "-  $( basename $romzip )"
	ui_print " "
	ui_print "------******!!!!!!!!!!!!!!!!!!!!******-------"
	fi
	if $flashrec ; then
	ui_print " "
	ui_print "------******!!!!!!RECOVERY!!!!!!******-------"
	ui_print "-  $( basename $reczip  )"
	ui_print " "
	ui_print "------******!!!!!!!!!!!!!!!!!!!!******-------"
	fi
	if $flashADDzip ; then 
		ui_print "------******!!ADDITIONAL ZIPS!!!******-------"
		for name in $( echo -e "$listADDzip" ) ; do
			ui_print "-  $( basename $name )"
		done
		ui_print " "
		ui_print "------******!!!!!!!!!!!!!!!!!!!!******-------"
	fi
	if $flash_custom_img ; then 
		ui_print "------*******!!!CUSTOM IMGS!!!********-------"
		nlines=$( grep -n "FLASHTOFLASH" "$home/custom_imgs_for_fw.txt" | awk '{print int($1)}' )
		for line in $nlines ; do 
			line=$(head -n$line "$home/custom_imgs_for_fw.txt" | tail -n1)
			if [[ -z $line ]] ; then continue ; else
			ui_print "-  CUSTOM img for fw: $( echo $( basename ${line%FLASHTOFLASH*} ) ) --> $( echo ${line#*FLASHTOFLASH} )" ; fi 
		done
		nlines=$( grep -n "FLASHTOFLASH" "$home/custom_imgs_for_super.txt" | awk '{print int($1)}' )
		for line in $nlines ; do 
			line=$(head -n$line "$home/custom_imgs_for_super.txt" | tail -n1)
			if [[ -z $line ]] ; then continue ; else 
			ui_print "-  CUSTOM img for super: $( echo $( basename ${line%FLASHTOFLASH*} ) ) --> $( echo ${line#*FLASHTOFLASH} )" ; fi 
		done
		ui_print " "
		ui_print "------******!!!!!!!!!!!!!!!!!!!!******-------"
	fi
	}
RUN_MOUNT_SUPER(){ 
	bakblock="/dev/block/backup/"
	case $1 in
	--mount-super)
    if ! $extsuper ; then
		umount /system_root ; umount /vendor ; umount /product ; umount /system_ext ; umount /odm
		block_system=$( grep "/system_root " /etc/fstab | awk '{ print $1 }' )
		block_system_ext=$( grep "/system_ext " /etc/fstab | awk '{ print $1 }' )
		block_vendor=$( grep "/vendor " /etc/fstab | awk '{ print $1 }' )
		block_product=$( grep "/product " /etc/fstab | awk '{ print $1 }' )
		block_odm=$( grep "/odm " /etc/fstab | awk '{ print $1 }' )

		system_back=false
		if [[ $block_system == "system" ]] ; then 
			line_block_system=$( grep "/system_root " /etc/fstab )
			new_line_block_system="$( grep "/system_root " /etc/fstab | awk '{ print "/dev/block/dm-15 "$2" "$3" "$4" "$5" "$6 }' )"
			sed -i 's|'"$line_block_system"'|'"$new_line_block_system"'|' /etc/fstab 
			block_system=/dev/block/dm-15 ; system_back=true
		fi
		system_ext_back=false
		if [[ $block_system_ext == "system_ext" ]] ; then 
			line_block_system_ext=$( grep "/system_ext " /etc/fstab )
			new_line_block_system_ext="$( grep "/system_ext " /etc/fstab | awk '{ print "/dev/block/dm-16 "$2" "$3" "$4" "$5" "$6 }' )"
			sed -i 's|'"$line_block_system_ext"'|'"$new_line_block_system_ext"'|' /etc/fstab 
			block_system_ext=/dev/block/dm-16 ; system_ext_back=true
		fi
		vendor_back=false
		if [[ $block_vendor == "vendor" ]] ; then 
			line_block_vendor=$( grep "/vendor " /etc/fstab )
			new_line_block_vendor=$( grep "/vendor " /etc/fstab | awk '{ print "/dev/block/dm-17 "$2" "$3" "$4" "$5" "$6 }' )
			sed -i 's|'"$line_block_vendor"'|'"$new_line_block_vendor"'|' /etc/fstab 
			block_vendor=/dev/block/dm-17 ; vendor_back=true
		fi
		product_back=false
		if [[ $block_product == "product" ]] ; then 
			line_block_product=$( grep "/product " /etc/fstab )
			new_line_block_product=$( grep "/product " /etc/fstab | awk '{ print "/dev/block/dm-18 "$2" "$3" "$4" "$5" "$6 }' )
			sed -i 's|'"$line_block_product"'|'"$new_line_block_product"'|' /etc/fstab 
			block_product=/dev/block/dm-18 ; product_back=true
		fi
		odm_back=false
		if [[ $block_odm == "odm" ]] ; then 
			line_block_odm=$( grep "/odm " /etc/fstab )
			new_line_block_odm=$( grep "/odm" /etc/fstab | awk '{ print "/dev/block/dm-19 "$2" "$3" "$4" "$5" "$6 }' )
			sed -i 's|'"$line_block_odm"'|'"$new_line_block_odm"'|' /etc/fstab 
			block_odm=/dev/block/dm-19 ; odm_back=true
		fi


		if [[ -z $block_system ]] && [[ -z $block_vendor ]] ; then 
			RUN_ABORT "28" "Something wrong: error 28"
		fi
		for img in $block_system $block_system_ext $block_vendor $block_product $block_odm ; do 
			mv $img "${img}.bak"
		done


		loop_system=$( losetup -f ) 
		# loop_system="/dev/block/dm-$nam_device" ; nam_device=$( calc $nam_device+20 )
		# mknod $loop_system b 7 $nam_device
		losetup $loop_system $home/imgs/system$newslot.img
		ln -s $loop_system $block_system


		loop_vendor=$( losetup -f ) 
		#loop_vendor="/dev/block/dm-$nam_device" ; nam_device=$( calc $nam_device+20 )
		# mknod $loop_vendor b 7 $nam_device
		losetup $loop_vendor $home/imgs/vendor$newslot.img
		ln -s $loop_vendor $block_vendor

		if [[ -f $home/imgs/system_ext$newslot.img ]] ; then
			loop_system_ext=$( losetup -f ) 
			# loop_system_ext="/dev/block/dm-$nam_device" ; nam_device=$( calc $nam_device+20 )
			# mknod $loop_system_ext b 7 $nam_device 
			losetup $loop_system_ext $home/imgs/system_ext$newslot.img
			ln -s $loop_system_ext $block_system_ext
		fi

		if [[ -f $home/imgs/product$newslot.img ]] ; then
			loop_product=$( losetup -f ) 
			# loop_product="/dev/block/dm-$nam_device" ; nam_device=$( calc $nam_device+20 )
			# mknod $loop_product b 7 $nam_device
			losetup $loop_product $home/imgs/product$newslot.img
			ln -s $loop_product $block_product
		fi

		if [[ -f $home/imgs/odm$newslot.img ]] ; then
			loop_odm=$( losetup -f ) 
			# loop_odm="/dev/block/dm-$nam_device" ; nam_device=$( calc $nam_device+20 )
			# mknod $loop_odm b 7 $nam_device
			losetup $loop_odm $home/imgs/odm$newslot.img
			ln -s $loop_odm $block_odm
		fi
		extsuper=true
    fi
	;;
	--mount-fw)
		if ! $extfw ; then
		for fwimg in $( find $home/fw/*.img ) $( find $home/boot/*.img ) ; do
			[[ -d /dev/block/backup ]] || mkdir /dev/block/backup
			bakblock="/dev/block/backup/"
			naked_name=$( basename ${fwimg%.img*} )
			if ! ( file /dev/block/by-name/$naked_name | grep "cannot open" ) ; then
				block="/dev/block/by-name/$naked_name"
			elif ! ( file /dev/block/by-name/$naked_name$slot_ab | grep "cannot open" ) ; then
				block="/dev/block/by-name/$naked_name$slot_ab"
			fi
			if ( file $block | grep "symbolic link" ) ; then
				linkblock=$( readlink $block )
				dd if=$linkblock of=${bakblock}$( basename $linkblock )
				dd if=$fwimg of=$linkblock
				echo "${linkblock}LOLLOLLOLFACK$fwimg" >> $home/list_block.txt
			fi
		done
		extfw=true
	    fi
	;;
	--umount-super) 
	if $extsuper ; then 
		RUN_ALL_MAUNT --umount
	if [[ -z $block_system ]] ; then 
		RUN_ABORT "10" "Something wrong: error 10"
	else
		umount /system_root ; umount /vendor ; umount /product ; umount /system_ext ; umount /odm
		
		if $system_ext_back ; then
			sed -i 's|'"$new_line_block_system_ext"'|'"$line_block_system_ext"'|' /etc/fstab 
		fi
		if $system_back ; then 
			sed -i 's|'"$new_line_block_system"'|'"$line_block_system"'|' /etc/fstab 
		fi
		if $vendor_back ; then
			sed -i 's|'"$new_line_block_vendor"'|'"$line_block_vendor"'|' /etc/fstab 
		fi
		if $product_back ; then
			sed -i 's|'"$new_line_block_product"'|'"$line_block_product"'|' /etc/fstab 
		fi
		if $odm_back ; then 
			sed -i 's|'"$new_line_block_odm"'|'"$line_block_odm"'|' /etc/fstab 
		fi

		for img in $block_system $block_system_ext $block_vendor $block_product $block_odm ; do 
			rm $img
			mv ${img}.bak $img
		done
		for img in $loop_system $loop_system_ext $loop_vendor $loop_product $loop_odm ; do 
			rm $img
		done 
	fi
	extsuper=false
    fi
    ;;
    --umount-fw)
	if $extfw ; then 
	for fwimg in $( cat $home/list_block.txt ) ; do
		bakblock="/dev/block/backup/"
		rm -f ${fwimg#*LOLLOLLOLFACK}
		dd if="${fwimg%LOLLOLLOLFACK*}" of="${fwimg#*LOLLOLLOLFACK}"
		dd if=$bakblock$( basename ${fwimg%LOLLOLLOLFACK*} ) of="${fwimg%LOLLOLLOLFACK*}"
	
	done
	extfw=false
	fi
	;;	 
	esac
	}
RUN_MAKE_SUPER(){
	ui_print "-  Make new super partition"
    ms=$(grep -F "Metadata max size:" $LPDUMP | awk '{print $4}')
    mslot=$(grep -F "Metadata slot count:" $LPDUMP | awk '{print $NF}')
    Ss=$( grep -F "Size:" $LPDUMP | awk '{print $2}' )
    gp=$( grep -F "part" $LPDUMP | grep -F "Name" | grep -F "$newslot"| awk '{print $NF}' )
    partadd=$(  for img in $(find $home/imgs/*.img) ; do
                    bimg=$(basename ${img})
                    part_ab=${bimg//.*}
                    img_size=$(stat -c%s $img)
                    [ -z $gp ] && echo -n "--partition ${part_ab}:none:$img_size:qti_dynamic_partitions$newslot "
                    [ -z $gp ] || echo -n "--partition ${part_ab}:none:$img_size:$gp "
                    echo -n "--image ${part_ab}=$img "
                done
         )
    [ -z $gp ] || echo "--metadata-size $ms --super-name super --sparse --metadata-slots $mslot --device super:$Ss --group $gp:$Ss $partadd --output $home/newsuper.img" >> $home/argslp.txt
    [ -z $gp ] && echo "--metadata-size $ms --super-name super --sparse --metadata-slots $mslot --device super:$Ss --group qti_dynamic_partitions$newslot:$Ss $partadd --output $home/newsuper.img" >> $home/argslp.txt
    ui_print "-  Creation of newsuper.img. For OTG process very long 40-50 minutes. Please wait..."
    lpmake $(cat "$home/argslp.txt") && retpop=40 || retpop=41
    if [[ $retpop == 41 ]] ; then 
        rm -f $home/argslp.txt
        [ -z $gp ] || echo "--metadata-size 65536 --super-name super --sparse --metadata-slots $mslot --device super:$Ss --group $gp:$Ss $partadd --output $home/newsuper.img" >> $home/argslp.txt
        [ -z $gp ] && echo "--metadata-size 65536 --super-name super --sparse --metadata-slots $mslot --device super:$Ss --group qti_dynamic_partitions$newslot:$Ss $partadd --output $home/newsuper.img" >> $home/argslp.txt
        lpmake $(cat "$home/argslp.txt") && retpop=40 || retpop=41
    fi

	}	
RUN_SINGL_STRUCTURES(){
	ui_print "-  Starting SINGL STRUCTURES"
	ui_print "-  Unpack $romzip wait..."
	if [[ $1 == "54" ]] ; then 
		7za e "$romzip" -o$home/newdat/ "*.new.dat*" "*.transfer.list" "*.img" -y -r -mmt8 >> $home/7zip.txt
		for fwimgs in $( find $home/newdat/*.img ) ; do
	        mv $fwimgs $home/fw/
	    done
	    for imgs in $( find $home/newdat/*new.dat.br ) ; do
	    	ui_print "-  Convert $( basename $imgs )"
	        brotli -df $imgs -o ${imgs%.br*} && rm -f $imgs
	    done
	    for imgs in $( find $home/newdat/*new.dat ) ; do
	    	ui_print "-  Convert $( basename $imgs )"
	        sdat2img ${imgs%.new.dat*}.transfer.list $imgs ${imgs%.new.dat*}$newslot.img
	    done
	    for cust in $( find $home/newdat/cust*.img); do
	    	mv $cust $home/fw/cust.img
	    done
		for imgs in $( find $home/newdat/*.img ) ; do
	        mv $imgs $home/imgs/
	    done
	    rm -f $home/newdat/*
	elif [[ $1 == "56" ]] ; then 
		7za e "$romzip" -o$home/newdatsuper/ "*.new.dat*" "*.transfer.list" "*.img" -y -r -mmt8 >> $home/7zip.txt
		for fwimgs in $( find $home/newdatsuper/*.img ) ; do
	        mv $fwimgs $home/fw/
	    done
	    for imgs in $( find $home/newdatsuper/*new.dat.br ) ; do
	    	ui_print "-  Convert $( basename $imgs )"
	        brotli -df $imgs -o ${imgs%.br*} && rm -f $imgs
	    done
	    for imgs in $( find $home/newdatsuper/*new.dat ) ; do
	    	ui_print "-  Convert $( basename $imgs )"
	        sdat2img ${imgs%.new.dat*}.transfer.list $imgs ${imgs%.new.dat*}$newslot.img
	    done
	    mv $home/newdatsuper/${r%.new.dat*}$newslot.img $home/newdatsuper/super.img
	    for cust in $( find $home/newdatsuper/cust*.img); do
	    	mv $cust $home/fw/cust.img
	    done
	    if [[ -f $home/newdatsuper/super.img ]] ; then
	    	if ( file $home/newdatsuper/super.img | grep -q sparse ) ; then 
			    simg2img $home/newdatsuper/super.img $home/newdatsuper/super.row.img
			    rm $home/newdatsuper/super.img
			    mv $home/newdatsuper/super.row.img $home/newdatsuper/super.img
		    fi
            mkdir $home/newdatsuper/super
		    lpunpack $home/newdatsuper/super.img $home/newdatsuper/super
		    for imgs in system_ext_a system_a vendor_a product_a odm_a ; do
		        for imgsp in $( find $home/newdatsuper/super/$imgs.img ) ; do 
			            mv $imgsp $home/imgs/${imgs%_a*}$newslot.img
		        done
		    done
		    rm $home/newdatsuper/super.img
		else
			RUN_ABORT "11" "Something wrong: error 11"
		fi
	    rm -f $home/newdatsuper/*
	elif [[ $1 == "53" ]] ; then
		7za e "$romzip" -o$home/super/ "*.img" -y -r -mmt8 >> $home/7zip.txt
        for img in $( find $home/super/*.img ) ; do
            if ( zstd -l $img ) ; then 
                zstd -c -d $img > ${img%.img*}.d.img && rm -f $img && mv ${img%.img*}.d.img $img
            fi
        done
	    if ( file $home/super/super.img | grep -q sparse ) ; then 
		    simg2img $home/super/super.img $home/super/super.row.img
		    rm $home/super/super.img
		    mv $home/super/super.row.img $home/super/super.img
	    fi
        mkdir $home/super/super
	    lpunpack $home/super/super.img $home/super/super
	    for imgs in system_ext_a system_a vendor_a product_a odm_a ; do
	        for imgsp in $( find $home/super/super/$imgs*.img ) ; do 
	            mv $imgsp $home/imgs/${imgs%_a*}$newslot.img
	        done
	    done
	    rm $home/super/super.img
	    for fwimgs in $( find $home/super/*.img ) ; do
	        mv $fwimgs $home/fw/
	    done
	elif [[ $1 == "52" ]] ; then 
		7za e "$romzip" -o$home/nonsuper/ "*.img" -y -r -mmt8 >> $home/7zip.txt
        for img in $( find $home/nonsuper/*.img ) ; do
            if ( zstd -l $img ) ; then 
                zstd -c -d $img > ${img%.img*}.d.img && rm -f $img && mv ${img%.img*}.d.img $img
            fi
        done
		for bootimgs in "vendor_boot" "boot" ; do  
	        bootimgsp=$( find $home/nonsuper/$bootimgs*.img )
	        mv $bootimgsp $home/fw/
	    done
	    for imgs in system_ext vendor system product odm ; do
	        imgsp=$( find $home/nonsuper/$imgs* )
	        mv $imgsp $home/imgs/${imgs}${newslot}.img
	    done
	    for fwimgs in $( find $home/nonsuper/*.img ) ; do
	        mv $fwimgs $home/fw/
	    done
	    rm -f $home/fw/super*.img
	elif [[ $1 == "51" ]] ; then 
		pydump -c 8 -o $home/payload/ "$romzip"
	    for bootimgs in vendor_boot boot ; do  
	        bootimgsp=$( find $home/payload/$bootimgs*.img )
	        mv $bootimgsp $home/fw/
	    done
	    for imgs in system_ext system vendor product odm ; do

	        imgsp=$( find $home/payload/$imgs*.img )
	        #ui_print "-  Move $imgsp"
	        mv $imgsp $home/imgs/${imgs}$newslot.img
	    done
	    for fwimgs in $( find $home/payload/*.img ) ; do
	        mv $fwimgs $home/fw/
	    done
	elif [[ $1 == "55" ]] ; then 
		7za e "$romzip" -o$home/ "payload.bin" -y -r -mmt8 >> $home/7zip.txt
		pydump -c 8 -o $home/payload/ "$home/payload.bin"
		rm -f $home/payload.bin
	    for bootimgs in vendor_boot boot ; do  
	        bootimgsp=$( find $home/payload/$bootimgs*.img )
	        mv $bootimgsp $home/fw/
	    done
	    for imgs in system_ext system vendor product odm ; do
	        imgsp=$( find $home/payload/$imgs*.img )
	        #ui_print "-  Move $imgsp"
	        mv $imgsp $home/imgs/${imgs}$newslot.img
	    done
	    for fwimgs in $( find $home/payload/*.img ) ; do
	        mv $fwimgs $home/fw/
	    done
	fi
	( grep "Unexpected end of archive" $home/7zip.txt ) && RUN_ABORT "26" "You $( basename $romzip ) damaged, you need to redownload it"
	for img in $( find $home/imgs/*.img $home/fw/*.img ); do
		if  [[ $( file $img | grep "sparse" ) ]] ; then
			ui_print "-  simg2img $( basename $img )"
			simg2img $img $( dirname $img )/$( basename ${img%.img*} ).raw.img
			rm -f $img ; mv $( dirname $img )/$( basename ${img%.img*} ).raw.img $img
		fi
	done
	if ! [[ -f $home/imgs/system$newslot.img ]] && ! [[ -f $home/imgs/vendor$newslot.img ]] ; then 
		RUN_ABORT "27" "Something wrong: error 27"
	fi
	mkdir /tmp/mntsystemtest
	mount -r $home/imgs/system$newslot.img /tmp/mntsystemtest
	if ( cat /tmp/mntsystemtest/system/build.prop | grep aospa ) && ( getprop ro.product.device | grep "alioth" ) ; then
		if ! [[ -f /tmp/passaospa.txt ]] ; then
			echo "pass" >> /tmp/passaospa.txt
			RUN_ABORT "93" "AOSPA Detected!!" "According to the latest news, it has a new type of data reading" \
			"For it to work correctly, you need to format the data, even if you have used or are using DFE" \
			"If you are sure about this, then you just need to flash MFP.zip again, and there will be no error" \
			"If you are sure about this, then you just need to flash MFP.zip again, and there will be no error"
		fi
	fi
	umount /tmp/mntsystemtest
	if ! $sm8250skip ; then
		mkdir /tmp/mntvendortest
		mount -r $home/imgs/vendor$newslot.img /tmp/mntvendortest
		if ( mountpoint -q /tmp/mntvendortest ) && [[ -f /tmp/mntvendortest/etc/fstab.sm8250 ]] && ( getprop ro.product.device | grep "alioth" ) ; then
			umount /tmp/mntvendortest
			RUN_ABORT "90" " " "HentaiOS or HentaiOS tree is not supported" \
			"If you are sure that this is not a HentaiOS tree and the system will work stably with then change the argument" \
			"SM8250 SKIP CHECK - yes" " " "Otherwise, I just don't want to deal with these guys, let them live in their own little world." \
			"I will not solve all the related problems of the HOS tree, it's a waste of time"
		elif ! ( mountpoint -q /tmp/mntvendortest ) ; then 
			RUN_ABORT "91" " " "What a mistake, how did you even get here?" "In any case, it is not possible to mount the vendor partition"
		fi
		umount /tmp/mntvendortest
	fi
	}
RUN_DUMP_PART(){
	if [ $(/tmp/bin/toybox df $home | awk ' NR==2 { if ($4 > 15843545) print "1" }') == "1" ] ; then 
		ui_print "-  Size normal: $( calc "$( /tmp/bin/toybox df $home | awk ' NR==2 { print $4 }' )/1024" )MB"
	else
		RUN_ABORT "12" "Not enough free space" \
		"you have $( calc "$( /tmp/bin/toybox df $home | awk ' NR==2 { print $4 }' )/1024/1024" )GB" \
		"Need 15~gb free space"
	fi
	ui_print "-  Starting dumping partition"
	for part in $(find /dev/block/mapper/*$newslot) ; do
		ui_print "-  Dumpimg $(basename $part)" 
		dd if=$part of=$home/imgs/$(basename $part).img
	done
	}
RUN_ALL_MAUNT(){
	for mnt in vendor system_root odm system_ext product ; do
		case "$1" in
			--mount )
				umount /$mnt
				mount /$mnt
				mount -o rw,remount /$mnt
				;;
			--umount )
				umount /$mnt
				;;
		esac
	done
	}
RUN_CHECK_ROM(){
		if [[ $( /tmp/bin/toybox df $home | awk ' NR==2 { if ($4 > 25843545) print "1" }' ) == "1" ]] ; then
			ui_print "-  Size normal: $( calc "$( /tmp/bin/toybox df $home | awk ' NR==2 { print $4 }' )/1024" )MB"
		else
			RUN_ABORT "13" "Not enough free space" \
			"You have $( calc ""$( /tmp/bin/toybox df $home | awk ' NR==2 { print $4 }' )"/1024/1024" )GB" \
			"Need 24gb free space"
		fi
		if [[ -f $romzip ]] && $flashrom ; then
		    #ui_print "-  $romzip find"
		    if $( 7za l "$romzip" | grep -q payload.bin ) ; then 
		        ui_print "-  Detected payload.bin"
		        if [[ $( stat -c%s $romzip ) -ge 3221225472 ]] ; then
		        return 55
		    	else
		    	return 51
		    	fi

		    elif $( 7za l "$romzip" | grep -q super.img ) && $( 7za l "$romzip" | grep -q system.img ) && $( 7za l "$romzip" | grep -q vendor.img ); then
		        ui_print "-  Detected fastboot rom"
		        return 52
		    elif $( 7za l "$romzip" | grep -q super.img ); then
		        ui_print "-  Detected fastboot with super.img rom"
		        return 53
		    elif $( 7za l "$romzip" | grep -q system.img ) && $( 7za l "$romzip" | grep -q vendor.img ); then
		        ui_print "-  Detected fastboot rom"
		        return 52
		    elif $( 7za l "$romzip" | grep -q ".new.dat" ) ; then 
		    	mkdir -pv $home/newdatsuper
		    	ui_print "-  Detected miui style"
		    	7za e "$romzip" -o$home/newdatsuper/ "updater-script" -y -r -mmt8
		    	if ( grep "/super" $home/newdatsuper/updater-script | grep block_image_update ) ; then
		    		ui_print "-  Detected miui style rom with super"
		    		r=$( grep "/super" $home/newdatsuper/updater-script | grep block_image_update )
		    		r=${r#*package_extract_file} ; r${r%||*}
		    		r=$( echo $r | awk '{ print $2 }' )
		    		r=${r#*\"} ; r=${r%\"*}
		    		return 56
		    	elif $( 7za l "$romzip" | grep -q system.new.dat ) || $( 7za l "$romzip" | grep -q system.new.dat.br ); then
		            ui_print "-  Detected miui style rom with part"
		            return 54 
		        fi
		    fi
		else 
		    RUN_ABORT "14" "$romzip not find"
		fi
	}
RUN_DFE(){
	ui_print "-  Starting DFE patch"
	sm8250=false
	size_c=false
	fstab_here=false
	path_to=/vendor
	#ui_print "-  Starting patching fstabes"
	for fstabes in $( find $path_to/etc/*fstab* ) ; do
		size_c2=false
		if ( grep "/userdata" $fstabes ) && ( grep "/metadata" $fstabes ) ; then 
			#ui_print "-  $( basename $fstabes )"
			while (grep "fileencryption=" $fstabes) || (grep "forcefdeorfbe=" $fstabes) || (grep "encryptable=" $fstabes) \
                || (grep "forceencrypt=" $fstabes) || (grep "metadata_encryption=" $fstabes) || (grep "keydirectory=" $fstabes) \
                || (grep "avb=" $fstabes) || (grep "avb_keys=" $fstabes) ; do
                k=$(cat $fstabes)
				for ffff in "fileencryption=" "forcefdeorfbe=" "encryptable=" "forceencrypt=" "metadata_encryption=" "keydirectory=" "avb=" "avb_keys="
                do
                    grep "$ffff" $fstabes && rem="${k#*"$ffff"}" && rem="${rem%%,*}" && rem="${ffff}${rem%%"$tabes"*}" || continue
                    grep ",$rem" $fstabes && sed -i 's|,'$rem'||' $fstabes && size_c=true && size_c2=true #&& ui_print "-  Flag ${rem#*"$ffff"}" 
                    grep "$rem" $fstabes && sed -i 's|'$rem'||' $fstabes && size_c=true && size_c2=true #&& ui_print "-  Flag ${rem#*"$ffff"}"
                done 
			done
			grep "avb" $fstabes && sed -i 's|,avb||g' $fstabes && size_c=true && size_c2=true #&& ui_print "-  Remove avb"
            grep "quota" $fstabes && sed -i 's|,quota||g' $fstabes && size_c=true && size_c2=true #&& ui_print "-  Remove quota"
            grep "inlinecrypt" $fstabes && sed -i 's|,inlinecrypt||g' $fstabes && size_c=true && size_c2=true #&& ui_print "-  Remove inlinecrypt"
            grep "wrappedkey" $fstabes && sed -i 's|,wrappedkey||g' $fstabes && size_c=true && size_c2=true #&& ui_print "-  Remove weappedkey"
			if [[ $( stat -c%s $fstabes ) -ge 30 ]] && $size_c2 ; then 
				ui_print "-  $(basename $fstabes): Has been succesfully patched"
				fstab_here=true
            elif [[ $( stat -c%s $fstabes ) -ge 30 ]] && ! $size_c2 ; then 
            	ui_print "-  $( basename $fstabes ): Doesn't need patching"
            	fstab_here=true
			else
				RUN_ABORT "15" \
				"Something wrong: error 15"
			fi
		fi
	done
	$fstab_here || RUN_ABORT "29" "Something wrong: error 29"
	}
RUN_CHECK_RW(){
	for mnt in /system_root/system /vendor/etc ; do 
		echo "test test test TEST TESTR TEST" >> $mnt/test.txt
		if [[ $( stat -c%s $mnt/test.txt ) -ge 6 ]] ; then
			rm -f $mnt/test.txt
		else
			return 41
		fi
	done
	return 40
	}
RUN_RW(){
	asdf=$( basename $1 )
	umount /tmp/$( basename ${asdf%.img*} )
	imgsize=$( stat -c%s $1 ) 
	new_size=$( calc "$imgsize*1.25/512" ) 
	echo "  -  $1 $imgsize $new_size"
	resize2fs -f $1 ${new_size}s
	e2fsck -y -E unshare_blocks $1
	resize2fs -f -M $1
	resize2fs -f -M $1

	}
RUN_RWS(){
	asdf=$( basename $1 )
	umount /tmp/$( basename $1 )
	psize=$2
	imgsize=$( stat -c%s $1 ) 
	new_size=$( calc "($imgsize+$2)/512" )
	#ui_print "-  Give RW "${asdf%"$newslot".img*}" - size: $(calc "($imgsize+$2)/1024/1024")MB. Free: $(calc "$2/1024/1024")MB"
	echo "  -  $1 $imgsize $new_size"
	resize2fs -f $1 ${new_size}s

	}
RUN_RECOVERY_REFLASH(){
	ui_print "-  Starting recovery reflash"
	dd if=/dev/block/by-name/boot$slot_ab of=/tmp/bin/boot.img
	cd /tmp/bin ; magiskboot unpack boot.img
	rm -f ramdisk.cpio
	mv /tmp/bin/twrp/ramdisk.cpio /tmp/bin/
	cpio ramdisk.cpio sha1
	magiskboot repack boot.img
	dd if=/tmp/bin/new-boot.img of=/dev/block/by-name/boot$slot_ab
	rm -rf "twrp" "ramdisk*" "*.img" "kernel*"
	}
RUN_FINAL(){
	RUN_FW_FLASH
	if $DM_VERY || $DM_VERI ; then
		if [ $newslot == $slot_ab ] ; then
			$DM_VERY && avbctl --force disable-verity 
			$DM_VERI && avbctl --force disable-verification
		else
			dd if=/dev/block/by-name/vbmeta$newslot of=/dev/block/by-name/vbmeta$slot_ab
			dd if=/dev/block/by-name/vbmeta_system$newslot of=/dev/block/by-name/vbmeta_system$slot_ab
			$DM_VERY && avbctl --force disable-verity 
			$DM_VERI && avbctl --force disable-verification
			dd if=/dev/block/by-name/vbmeta$slot_ab of=/dev/block/by-name/vbmeta$newslot
			dd if=/dev/block/by-name/vbmeta_system$slot_ab of=/dev/block/by-name/vbmeta_system$newslot
		fi
		$DM_VERI && ddd=$( avbctl get-verification )
		$DM_VERY && ddf=$( avbctl get-verity )
		$DM_VERI && ddd="${ddd%"$slot_ab"*}${newslot}."
		$DM_VERY && ddf="${ddf%"$slot_ab"*}${newslot}."
		$DM_VERY && ui_print "-  $ddf"
		$DM_VERI && ui_print "-  $ddd"
	fi
	if [ $newslot == "_a" ] ; then

		bootctl set-active-boot-slot 0

	else 
		bootctl set-active-boot-slot 1
	fi
	if $flashrec || $reflashrec ; then 
		rm -f /data/system/storage.xml
	fi
	if $flashdfe ; then 
		ui_print "-------******!!!!!!!!!!!!!!!!!!!!******------"
		ui_print "---***|      Comlite decryption!      |***---"
		ui_print "---*If you are encrypted, you need to do**---"
		ui_print "---***|          Format data          |***---"
		ui_print "-If you Decrypted and change the ROM, after--"
		ui_print "-flashing the new ROM, you need to flash the-"
		ui_print "----DFE again, you are also advised to do*---"
		ui_print "---***|           Wipe Data           |***---"
		ui_print "--If you are upgrading the ROM you need to---"
		ui_print "---***|       flash the DFE again     |***---"
		ui_print "------******!!!!!!!!!!!!!!!!!!!!******-------"
	fi
		ui_print  "------******!!!!!!!!!!!!!!!!!!!!******-------"
		ui_print  "------      Installing complited      -------"
		ui_print  "------******!!!!!!!!!!!!!!!!!!!!******-------"
	RUN_WRITE_LOG
	$delhome && rm -rf $home

	if ( mountpoint -q /data ) ; then
		if $wipedata ; then
			ui_print "-  wiping data"
			for del in $( ls -a /data ) ; do
				if [[ $del == '.' ]] || [[ $del == '..' ]] || [[ $del == media ]] ; then
					continue
				else
					rm -rf /data/$del
				fi
			done
		fi
	fi
		
		if $rebootafter ; then
			ui_print "-  Rebooting to $rebootARG in 7 seconds..."
			sleep 1 ; ui_print "-  7s..."
			sleep 1 ; ui_print "-  6s..."
			sleep 1 ; ui_print "-  5s..."
			sleep 1 ; ui_print "-  4s..."
			sleep 1 ; ui_print "-  3s..."
			sleep 1 ; ui_print "-  2s..."
			sleep 1 ; ui_print "-  1s..."
			sleep 1 ; ui_print "-  0s..."
			sleep 1
			reboot $rebootARG
		fi
		exit 0 
	}
RUN_ALL_RW(){
	if ! [[ -f $home/imgs/vendor$newslot.img ]] && ! [[ -f $home/imgs/system$newslot.img ]] ; then
		RUN_ABORT "24" "Something wrong: error 24"
	fi
	ui_print "-  Give RW for all partition"
	for img_rw in vendor system_ext product system odm ; do
		[[ -f $home/imgs/$img_rw$newslot.img ]] && RUN_RW "$home/imgs/$img_rw$newslot.img"
	done
	Ss=$( grep -F -m 1 "Size:" $LPDUMP | awk '{print $2}' )
	vs=$( stat -c%s $home/imgs/vendor$newslot.img )
	ss=$( stat -c%s $home/imgs/system$newslot.img )
	if [ -f $home/imgs/product$newslot.img ] ; then 
	    ps=$(stat -c%s $home/imgs/product$newslot.img)
	    psf=true
	else
	    psf=false 
	    ui_print "-  NON product" && ps=0
	fi
	if [ -f $home/imgs/system_ext$newslot.img ] ; then 
	    sss=$(stat -c%s $home/imgs/system_ext$newslot.img)
	    sssf=true
	else 
	    sssf=false
	    ui_print "-  NON system_ext" && sss=0
	fi
	if [ -f $home/imgs/odm$newslot.img ] ; then 
	    odms=$(stat -c%s $home/imgs/odm$newslot.img)
	else ui_print "-  NON odm" && odms=0
	fi

	echo "-  $Ss $vs $ss $ps $sss $odms"
	ssfree=$( calc "$Ss-$vs-8388608-$ss" )
	ssfree=$( calc "$ssfree-$odms-$sss-$ps" )
	tfs=$( calc "$ssfree/1024" )
	echo "  -  $ssfree $tfs"
	if [ $tfs -gt 1 ] ; then
	    if $psf && $sssf ; then
	    	#ui_print "-  Full complect"
	        nss=$( calc "$ssfree/3" )
	        nvs=$( calc "($ssfree-$nss)/2" )
	        nps=$( calc "($ssfree-$nss-$nvs)/2" )
	        nsss=$( calc "$ssfree-$nss-$nvs-$nps" )
	    fi
	    if ! $psf && $sssf ; then
	    	#ui_print "-  NON product"
	        nss=$( calc "$ssfree/3" )
	        nvs=$( calc "($ssfree-$nss)/2" )
	        nsss=$( calc "$ssfree-$nss-$nvs" )
	    fi
	    if $psf && ! $sssf ; then
	    	#ui_print "- NON system_ext"
	        nss=$( calc "$ssfree/3" )
	        nvs=$( calc "($ssfree-$nss)/2" )
	        nps=$( calc "$ssfree-$nss-$nvs" )
	    fi
	    if ! $psf && ! $sssf ; then 
	    	#ui_print "-  NON product and system_ext"
	        nss=$( calc "$ssfree/2" )
	        nvs=$( calc "$ssfree-$nss" )
	    fi
	    echo "  -  $nss $nvs $nps $nsss"
	    RUN_RWS "$home/imgs/system$newslot.img" "$nss" 
	    RUN_RWS "$home/imgs/vendor$newslot.img" "$nvs"
	    $psf && RUN_RWS "$home/imgs/product$newslot.img" "$nps"
	    $sssf && RUN_RWS "$home/imgs/system_ext$newslot.img" "$nsss"
	else 
	    ui_print "-  Unable to expand memory, super will be built with old parameters"

	fi
	}
RUN_RECOVERY_FLASH(){
		ui_print "-  Starting recovery Flashing $( basename $reczip )"
		if [[ -f $reczip ]] ; then 
			case $reczip in
				*.img) 
				cp $reczip /tmp/bin/twrp.img
					;;
				*.zip) 
				cp $reczip /tmp/rec.zip
				reczip="/tmp/rec.zip"
				7za e "$reczip" -o/tmp/bin/ "recovery.img" -y -r -mmt8
				mv /tmp/bin/recovery.img /tmp/bin/twrp.img
				;;
			esac
			mkdir -pv /tmp/bin/twrp
			mv /tmp/bin/twrp.img /tmp/bin/twrp/twrp.img
			dd if=/dev/block/by-name/boot$slot_ab of=/tmp/bin/boot.img
			cd /tmp/bin ; magiskboot unpack boot.img
			rm -f ramdisk.cpio
			cd /tmp/bin/twrp ; magiskboot unpack twrp.img
			mv /tmp/bin/twrp/ramdisk.cpio /tmp/bin/ramdisk.cpio
			cd /tmp/bin/ 
			cpio ramdisk.cpio sha1
			magiskboot repack boot.img
			dd if=/tmp/bin/new-boot.img of=/dev/block/by-name/boot$slot_ab
			rm -rf "twrp" "ramdisk*" "*.img" "kernel*"
			retpop=40
		else
			ui_print "-  $reczip not finded"
			flashrec=false
			retpop=41
		fi
		}	
RUN_INIT_PATCH(){
	finit=1
	ui_print "-  Starting hide not encrypted"
    # while ! [[ -z $(head -n$finit /system_root/system/build.prop | tail -n1) ]] ; do
    #     finit=$( expr $finit + 1 )
    #     r=$(head -n$finit /system_root/system/build.prop | tail -n1)
    #     if ! [[ -z $r ]] && [[ $finit -gt 1300 ]] ; then
    #     	( grep "ro.crypto.state" /system_root/system/build.prop && \
		  #   sed -i '/ro.crypto.state/d' /system_root/system/build.prop && \
		  #   echo "ro.crypto.state=true" >> /system_root/system/build.prop ) || \
		  #   echo "ro.crypto.state=true" >> /system_root/system/build.prop
    #     	break
    #   	elif [[ -z $r ]] ; then
		( grep "ro.crypto.state" /system_root/system/build.prop && \
	    sed -i '/ro.crypto.state/d' /system_root/system/build.prop && \
	    sed -i "${finit}i \ ro.crypto.state=true" /system_root/system/build.prop ) || \
	    sed -i "${finit}i \ ro.crypto.state=true" /system_root/system/build.prop
    #   		break
    #   	fi

    # done 

	}
RUN_BOOT_PATCH(){
	ui_print "-  Starting boot patching"
	dd if=/dev/block/by-name/boot$1 of=/tmp/bin/boot.img
	cd /tmp/bin
	magiskboot unpack boot.img
	magiskboot cpio ramdisk.cpio patch
	for dt in dtb kernel_dtb extra kernel; do
		[ -f $dt ] && magiskboot dtb $dt patch 
	done
	if [ -f kernel ]; then
		magiskboot hexpatch kernel 49010054011440B93FA00F71E9000054010840B93FA00F7189000054001840B91FA00F7188010054 A1020054011440B93FA00F7140020054010840B93FA00F71E0010054001840B91FA00F7181010054
		magiskboot hexpatch kernel 821B8012 E2FF8F12
		magiskboot hexpatch kernel 736B69705F696E697472616D667300 77616E745F696E697472616D667300
	fi
	magiskboot repack boot.img
	dd if=/tmp/bin/new-boot.img of=/dev/block/by-name/boot$1
	rm -rf "twrp" "ramdisk*" "*.img" "kernel*"

	}
RUN_VENDORBOOT_PATCH(){
	ui_print "-  Starting vendor_boot patch"
	mkdir -pv /tmp/bin/vendor_boot
	dd if=/dev/block/by-name/vendor_boot$newslot of=/tmp/bin/vendor_boot/boot.img
	cd /tmp/bin/vendor_boot
	magiskboot unpack -h boot.img
	grep "androidboot.verifiedbootstate=green " header && sed -i 's|androidboot.verifiedbootstate=green ||' header
	grep "androidboot.vbmeta.device_state=locked " header && sed -i 's|androidboot.vbmeta.device_state=locked ||' header
	grep "androidboot.verifiedbootstate=green" header && sed -i 's|androidboot.verifiedbootstate=green||' header
	grep "androidboot.vbmeta.device_state=locked" header && sed -i 's|androidboot.vbmeta.device_state=locked||' header
	magiskboot repack boot.img vendor_boot.img
	dd if=/tmp/bin/vendor_boot/vendor_boot.img of=/dev/block/by-name/vendor_boot$newslot
	cd /tmp/bin
	rm -rf "vendor_boot"

	}
RUN_FW_FLASH(){
	for fw in $( find $home/fw/*img $home/boot/*img ) ; do
	    fwname=$( basename ${fw%.img*} )
	    ui_print "-  Flashing inbuild $fwname"
	    if ( file $fw | grep "sparse" ) ; then 
	    	simg2img $fw $fw.row
	    	rm -f $fw ; mv $fw.row $fw
	    fi
	    if ! ( file /dev/block/by-name/$fwname | grep "cannot open" ) ; then
	    	dd if=$fw of=/dev/block/by-name/$fwname
	    elif ! ( file /dev/block/by-name/$fwname$newslot | grep "cannot open" ) ; then
	    	dd if=$fw of=/dev/block/by-name/$fwname$newslot
	    fi
	done
	# if $flashlogo ; then
	# 	for fw in $( find $bootlogo/*img ) ; do
	# 	    fwname=$( basename ${fw%.img*} )
	# 	    ui_print "-  Flashing logo file $fwname"
	# 	    if ( file $fw | grep "sparse" ) ; then 
	# 	    	simg2img $fw $fw.row
	# 	    	rm -f $fw ; mv $fw.row $fw
	# 	    fi
	# 	    if ! ( file /dev/block/by-name/$fwname | grep "cannot open" ) ; then
	# 	    	dd if=$fw of=/dev/block/by-name/$fwname
	# 	    elif ! ( file /dev/block/by-name/$fwname$newslot | grep "cannot open" ) ; then
	# 	    	dd if=$fw of=/dev/block/by-name/$fwname$newslot
	# 	    fi
	# 	done
	# fi

	}
RUN_POST_PATCH(){
	if ( $flashrec && ! $reflashrec ) || ( $flashrec && $reflashrec ) ; then 
			RUN_RECOVERY_FLASH 
	elif ! $flashrec && $reflashrec ; then 
			RUN_RECOVERY_REFLASH
	fi

	$vendor_boot_patch && RUN_VENDORBOOT_PATCH
	$boot_patch && RUN_BOOT_PATCH
	}
RUN_RW_LITE(){
	for mnt in vendor system odm system_ext product ; do
		e2fsck -f /dev/block/mapper/${mnt}$slot_ab
	    blockdev --setrw /dev/block/mapper/${mnt}$slot_ab
	    e2fsck -E unshare_blocks -y -f /dev/block/mapper/${mnt}$slot_ab
	    resize2fs /dev/block/mapper/${mnt}$slot_ab
	done 
	}
RUN_FLASH_ZIPS(){

	for install in $( echo -e "$listADDzip" ) ; do
		mkdir -pv /tmp/addzip/$( basename ${install%.zip*} )
		unzip -o "$install" "META-INF/com/google/android/update-binary" -d /tmp/addzip/$( basename ${install%.zip*} )/
		ui_print "------******!!!!!!!!!!!!!!!!!!!!******-------"
		ui_print "------******!!!!!!!!!!!!!!!!!!!!******-------"
		ui_print "-  FLASHING $( basename $install )"
		ui_print "------******!!!!!!!!!!!!!!!!!!!!******-------"
		ui_print "------******!!!!!!!!!!!!!!!!!!!!******-------"
		chmod 777 /tmp/addzip/$( basename ${install%.zip*} )/META-INF/com/google/android/update-binary
		RUN_ALL_MAUNT --umount
		RUN_MOUNT_SUPER --umount-super
		RUN_MOUNT_SUPER --mount-super
		/tmp/addzip/$( basename ${install%.zip*} )/META-INF/com/google/android/update-binary $arg1 $arg2 "$install"		
	done
		ui_print "------******!!!!!!!!!!!!!!!!!!!!******-------"
		ui_print "------******!!!!!!!!!!!!!!!!!!!!******-------"
		ui_print "-  Complect installing all additional zips "
		ui_print "------******!!!!!!!!!!!!!!!!!!!!******-------"
		ui_print "------******!!!!!!!!!!!!!!!!!!!!******-------"
	}
RUN_FORCE_FPS(){

	ui_print "-  Forcing fps for all apps"
	finit=1
    while ! [[ -z $(head -n$finit /system_root/system/build.prop | tail -n1) ]] ; do
        finit=$( expr $finit + 1 )
        r=$(head -n$finit /system_root/system/build.prop | tail -n1)
        [[ -z $r ]] && break
    done 

    ( grep "fps.force.120" /system_root/system/build.prop && \
    sed -i '/fps.force.120/d' /system_root/system/build.prop && \
    sed -i "${finit}i fps.force.120=true" /system_root/system/build.prop ) || \
    sed -i "${finit}i fps.force.120=true" /system_root/system/build.prop

	rm -f /system_root/system/bin/pm && \
	cp /tmp/bin/force120hz /system_root/system/bin/pm && \
	chmod 777 /system_root/system/bin/pm

	}
RUN_FIX_FPS(){
	
	for file in $( find /tmp/bin/system_root/ /tmp/bin/vendor/ ) ; do 
		mkdir -pv $( dirname ${file#*/tmp/bin} )
		cp -f $file ${file#*/tmp/bin}
		chmod 777 ${file#*/tmp/bin}
	done


	}
RUN_MV_CIMG(){
	nlines=$( grep -n "FLASHTOFLASH" "$home/custom_imgs_for_fw.txt" | awk '{print int($1)}' )
	for lines in $nlines ; do 
		line=$(head -n$lines "$home/custom_imgs_for_fw.txt" | tail -n1)
		pathCimg=${line%FLASHTOFLASH*} ; flashtoCimg=${line#*FLASHTOFLASH}
		if ( file $pathCimg | grep "sparse" ) ; then
			rm -f $home/fw/$flashtoCimg.img
			simg2img $pathCimg $home/fw/$flashtoCimg.img
		else
			cp -F $pathCimg $home/fw/$flashtoCimg.img
		fi
	done
	nlines=$( grep -n "FLASHTOFLASH" "$home/custom_imgs_for_super.txt" | awk '{print int($1)}' )
	for lines in $nlines ; do 
		line=$(head -n$lines "$home/custom_imgs_for_super.txt" | tail -n1)
		pathCimg=${line%FLASHTOFLASH*} ; flashtoCimg=${line#*FLASHTOFLASH}
		if ( file $pathCimg | grep "sparse" ) ; then
			rm -f $home/fw/$flashtoCimg.img
			simg2img $pathCimg $home/imgs/$flashtoCimg.img
		else
			cp -F $pathCimg $home/imgs/$flashtoCimg.img
		fi
	done
	}



if ( echo "$( dirname "$arg3" )" | grep ' ' ) || ( echo "$arg3" | grep ' ' ) ; then
	RUN_ABORT "3" "Please remove spaces from the path name" \
	"Bad path /sdcard/folder name/mfp.zip" \
	"Good path /sdcard/foldername/folder-name/mfp.zip"
fi
zipname="$(basename "$arg3")" ; zipfolder="$(dirname "$arg3")"

( mountpoint -q /data ) || mount /data
unzip -o "$arg3" "busybox" -d /tmp/bin/
chmod 777 /tmp/bin/busybox
mkdir -pv /tmp/bin
mkdir -pv /tmp/lib
mkdir -pv /tmp/twrp
/tmp/bin/busybox unzip -o "$arg3" -d /tmp/
chmod 777 /tmp/bin/*
chmod 777 /tmp/lib/*
find /tmp/bin/* -exec ln -s {} /system/bin \; 
export PATH=/tmp/bin:$PATH 
slot_num=$(bootctl get-current-slot) ; slot_ab=$(bootctl get-suffix $slot_num)
if ( /tmp/bin/toybox mountpoint -q /sdcard/ ) ; then
	home="/sdcard/MFPAPP"
elif ( /tmp/bin/toybox mountpoint -q /data/ ) ; then
	mount /data/media/0 /sdcard
	if ( /tmp/bin/toybox mountpoint -q /sdcard/ ) ; then
		home="/sdcard/MFPAPP" 
	else
		home="/data/media/0/MFPAPP"
	fi
else
	if ( /tmp/bin/toybox mountpoint -q /usb_otg/ ) ; then 
		home="/usb_otg/MFPAPP" 
	else 
		RUN_ABORT "4" "Need OTG or mounted /sdcard/ for stable working" 
	fi
fi
rm -rf $home


sm8250=false ; extsuper=false ; nam_device=200 ; extfw=false
mkdir -pv $home ; mkdir -pv $home/payload
mkdir -pv $home/imgs ; mkdir -pv $home/super ; mkdir -pv $home/nonsuper 
mkdir -pv $home/newdatsuper ; mkdir -pv $home/fw ; mkdir -pv $home/newdat
n=1
[[ -d $home ]] || RUN_ABORT "21" "Cant creat $home folder"



CimgFT=false

case $zipname in
	*ARGOUT*)
		arguments=$zipfolder/arguments.txt
		;;
		   *)	
		/tmp/bin/busybox unzip -o "$arg3" "arguments.txt" -d /tmp/lib/
		arguments=/tmp/lib/arguments.txt
		;;
esac

RUN_READ_ARG
RUN_ARG_CHECK

if ! $sm8250skip && ! $flashrom ; then
	RUN_ALL_MAUNT --mount
	if ( mountpoint -q /vendor ) && [[ -f /vendor/etc/fstab.sm8250 ]] && ( getprop ro.product.device | grep "alioth" ) ; then
		RUN_ABORT "88" " " "HentaiOS or HentaiOS tree is not supported" \
		"If you are sure that this is not a HentaiOS tree and the system will work stably with then change the argument" \
		"SM8250 SKIP CHECK - yes" " " "Otherwise, I just don't want to deal with these guys, let them live in their own little world." \
		"I will not solve all the related problems of the HOS tree, it's a waste of time"
	elif ! ( mountpoint -q /vendor ) ; then 
		RUN_ABORT "89" " " "What a mistake, how did you even get here?" "In any case, it is not possible to mount the vendor partition"
	fi
fi

if ( echo $( basename $romzip ) | grep '(' ) || ( echo $( basename $romzip ) | grep ')' ) ; then
	RUN_ABORT "16" "Remove ) or ( in rom name"
fi 
LPDUMP="$home/lpdump.txt"
lpdump --slot=$newslot >> $LPDUMP
if ( grep "Size:" $LPDUMP ) ; then 
	echo "super fine"
else
	if ( getprop ro.product.device | grep "alioth" ) ; then
		simg2img /tmp/bin/super.img /dev/block/by-name/super
		rm -f $LPDUMP
		lpdump --slot=$newslot >> $LPDUMP
	else 
		RUN_ABORT "17"
	fi
fi 
if $flashrom || $flashADDzip || $flash_custom_img ; then
    if $flashrom ; then
	    RUN_CHECK_ROM
	    RUN_SINGL_STRUCTURES $?
	    $flash_custom_img && RUN_MV_CIMG
	elif ! $flashrom && ( $flashADDzip || $flash_custom_img ) ; then
        RUN_DUMP_PART
        $flash_custom_img && RUN_MV_CIMG
	fi
    
	if $flashADDzip || $flashdfe || $flashrw ; then 
		RUN_ALL_RW
	fi
	RUN_ALL_MAUNT --umount
	RUN_MOUNT_SUPER --mount-super
	RUN_MOUNT_SUPER --mount-fw
fi
	
RUN_ALL_MAUNT --mount ; RUN_CHECK_RW ; perm=$? 
if [[ $perm == 41 ]] ; then 
	if ! $flashrom && ! $flashADDzip ; then 
		RUN_RW_LITE ; RUN_ALL_MAUNT --mount ; RUN_CHECK_RW ; permm=$? ; perm=$permm
	fi ; fi
if ( [[ $permm == 41 ]] && ! $flashrom ) || ( $flashrw && ! $flashrom ) ; then 
	RUN_ALL_MAUNT --umount
	RUN_DUMP_PART
	$flash_custom_img && RUN_MV_CIMG
	RUN_ALL_RW
		if $flashdfe || $flashADDzip ; then
			RUN_MOUNT_SUPER --mount-super
			RUN_MOUNT_SUPER --mount-fw
			RUN_ALL_MAUNT --mount
			RUN_CHECK_RW ; perm=$? 
			if [[ $perm == 41 ]] ; then 
				RUN_ABORT "18" "Something wrong: 18"
			fi ; fi ; fi

$flashdfe && RUN_DFE 
$hide_no_encrypted && RUN_INIT_PATCH
$FORCE_FPS && RUN_FORCE_FPS
$FIX_FPS && RUN_FIX_FPS
RUN_POST_PATCH
$flashADDzip && RUN_FLASH_ZIPS
RUN_ALL_MAUNT --umount
RUN_MOUNT_SUPER --umount-super
RUN_MOUNT_SUPER --umount-fw
if [[ $permm == 41 ]] || $flashrw || $flashrom ; then
	RUN_MAKE_SUPER
	if [[ $retpop == 40 ]] ; then 
		ui_print "-  Flashing new SUPER partition. wait..."
		simg2img $home/newsuper.img /dev/block/by-name/super

	else
		RUN_ABORT "19" "Something wrong: error 19"
	fi
fi
RUN_FINAL
RUN_ABORT "0"
exit 0