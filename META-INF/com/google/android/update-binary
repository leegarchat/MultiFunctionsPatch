#!/sbin/sh

#Объявление основых переменных и постоянных функций
export OUTFD=$2

arg1=$1 ; arg2=$2 ; arg3=$3

ui_print() { echo -e "ui_print $1\nui_print" >> "/proc/self/fd/$arg2"; }
calc(){ awk 'BEGIN{ print int('$1') }' ; }
tabes="
"
MFPAPP="MFP-ALPHA-4.0.9"

zipname="$(basename "$arg3")" ; zipfolder="$(dirname "$arg3")"

slot_num=$(bootctl get-current-slot) ; slot_ab=$(bootctl get-suffix $slot_num)
unzip -o "$arg3" "busybox" -d /tmp/bin/
chmod 777 /tmp/bin/busybox

RUN_LOGO(){
	ui_print " "
	ui_print "  ------******!!!!!!!!!!!!!!!!!!!!******-------"
	ui_print " "
	ui_print "  -  $MFPAPP"
	ui_print "  -  by @LeeGarChat"
	ui_print "  -  Telegram group @PocoF3DFE"
	ui_print "  -  Thanks for @ErenMetesarr"
	ui_print " "
	ui_print "  ------******!!!!!!!!!!!!!!!!!!!!******-------"
	ui_print " "
	ui_print "  -  MAKERW: $flashrw"
	ui_print "  -  DFE: $flashdfe"
	ui_print "  -  MAGISK: $flashmagisk"
	ui_print "  -  REFLASH RECOVERY: $reflashrec"
	ui_print "  -  FLASH RECOVERY: $flashrec"
	ui_print "  -  INSLOT-A/B: $newslot"
	ui_print "  -  FLASH ROM: $flashrom"
	ui_print "  -  FLASH KERNEL: $flashker"
	}
RUN_ARG_EXAMPLE(){
	ui_print "  -  add args into arguments.txt out .zip or into .zip "
	ui_print "  -  arguments example"
	ui_print "             "
	ui_print "  MAKERW yes"
	ui_print "  REFLASH RECOVERY yes"
	ui_print "  FLASH ROM yes"
	ui_print "  FLASH RECOVERY yes"
	ui_print "  FLASH KERNEL yes"
	ui_print "  FLASH MAGISK yes"
	ui_print "  INSTALL SLOT _a/_b"
	ui_print "  Name rom rom_name.zip"
	ui_print "  Name recovery recovery_name.img/zip"
	ui_print "  Name magisk magisk_name.zip/apk"
	ui_print "  Name kernel kernel_name.zip"
	}
RUN_READ_ARG(){ 

	while ( grep "/storage/emulated/0/" $arguments ) ; do
		sed -i 's|/storage/emulated/0/|/sdcard/|g' $arguments
	done


	( grep "MAKERW" "$arguments" | grep -i "yes" ) && flashrw=true || flashrw=false

	( grep "DFE" "$arguments" | grep -i "yes" ) && flashdfe=true || flashdfe=false

	if ( grep "FLASH ROM" "$arguments" | grep -i "yes" ) ; then
		if ( grep "FULL PATH ROM" "$arguments" | grep -i "YES" ) ; then
			romzip=$(grep -i "full path to rom" "$arguments")
			romzip=${romzip#*\"} ; romzip=${romzip%\"*}
			if [[ -z $romzip ]] ; then flashrom=false ; else
				if [[ -f $romzip ]] ; then flashrom=true
				else ui_print "  -  Something wrong: error 144.5" ; exit 144 ; fi ; fi
		else
			name_rom=$(grep -i "name rom" "$arguments")
			name_rom=${name_rom#*\"} ; name_rom=${name_rom%\"*}
			if [[ -z $name_rom ]] ; then flashrom=false ; else romzip="$zipfolder/$name_rom"
				if [[ -f $romzip ]] ; then flashrom=true
				else ui_print "  -  Something wrong: error 144" ; exit 144 ; fi ; fi ; fi
	else flashrom=false ; fi
	if ( grep "FLASH RECOVERY" "$arguments" | grep -i "yes" ) ; then
		if ( grep -i "FULL PATH RECOVERY" "$arguments" | grep -i "YES" ) ; then
			reczip=$(grep -i "full path to recovery" "$arguments")
			reczip=${reczip#*\"} ; reczip=${reczip%\"*}
			if [[ -z $reczip ]] ; then flashrec=false ; else
				if [[ -f $reczip ]] ; then flashrec=true
				else ui_print "  -  Something wrong: error 140.5" ; exit 140 ; fi ; fi
		else
			name_rec=$(grep -i "name recovery" "$arguments")
			name_rec=${name_rec#*\"} ; name_rec=${name_rec%\"*}
			if [[ -z $name_rec ]] ; then flashrec=false ; else reczip="$zipfolder/$name_rec"
				if [[ -f $reczip ]] ; then flashrec=true
				else ui_print "  -  Something wrong: error 140" ; exit 140 ; fi ; fi ; fi
	else flashrec=false ; fi
	if ( grep "FLASH MAGISK" "$arguments" | grep -i "yes" ) ; then
		if ( grep -i "FULL PATH MAGISK" "$arguments" | grep -i "YES" ) ; then
			magiskzip=$(grep -i "full path to magisk" "$arguments")
			magiskzip=${magiskzip#*\"} ; magiskzip=${magiskzip%\"*}
			if [[ -z $magiskzip ]] ; then flashmagisk=false ; else 
				if [[ -f $magiskzip ]] ; then flashmagisk=true
			else ui_print "  -  Something wrong: error 141.5" ; exit 141 ; fi ; fi
		else 
			name_magisk=$(grep -i "name magisk" "$arguments")
			name_magisk=${name_magisk#*\"} ; name_magisk=${name_magisk%\"*}
			if [[ -z $name_magisk ]] ; then flashmagisk=false ; else magiskzip="$zipfolder/$name_magisk"
				if [[ -f $magiskzip ]] ; then flashmagisk=true
			else ui_print "  -  Something wrong: error 141" ; exit 141 ; fi ; fi ; fi
	else flashmagisk=false ; fi
	if ( grep "FLASH KERNEL" "$arguments" | grep -i "yes" ) ; then
		if ( grep -i "FULL PATH KERNEL" "$arguments" | grep -i "YES" ) ; then 
			kerzip=$(grep -i "full path to kernel" "$arguments")
			kerzip=${kerzip#*\"} ; kerzip=${kerzip%\"*}
			if [[ -z $kerzip ]] ; then flashker=false ; else
				if [[ -f $kerzip ]] ; then flashker=true
			else ui_print "  -  Something wrong: error 142" ; exit 142 ; fi ; fi
		else
			name_ker=$(grep -i "name kernel" "$arguments")
			name_ker=${name_ker#*\"} ; name_ker=${name_ker%\"*}
			if [[ -z $name_ker ]] ; then flashker=false ; else kerzip="$zipfolder/$name_ker"
				if [[ -f $kerzip ]] ; then flashker=true
			else ui_print "  -  Something wrong: error 142" ; exit 142 ; fi ; fi ; fi
			
	else flashker=false ; fi


	if ( grep "INSTALL SLOT" "$arguments" | grep -i "_a" ) ; then
		$flashrom && newslot="_a" || newslot="$slot_ab"
	elif ( grep "INSTALL SLOT" "$arguments" | grep -i "_b" ) ; then
		$flashrom && newslot="_b" || newslot="$slot_ab"
	else newslot="$slot_ab" ; fi

	if ( grep "REFLASH RECOVERY" "$arguments" | grep -i "yes" ) ; then 
		$flashrom && reflashrec=true || reflashrec=false
	else reflashrec=false ; fi

	}
RUN_ARG_CHECK_ZIP(){
	case $zipname in
		*ARGNAME*) ui_print "  -  Read args in name .zip" ;;
		  *ARGIN*) ui_print "  -  Read args into arguments.txt in .zip" ; return 88 ;;
		 *ARGOUT*) ui_print "  -  Read args out arguments.txt as folder .zip" ; return 89 ;;
	esac
	case $zipname in 
		*MAKERW*) flashrw=true ;; 
			   *) flashrw=false ;; 
	esac
	case $zipname in 
		*DFE*) flashdfe=true ;; 
		    *) flashdfe=false ;; 
	esac
	case $zipname in 
		*FROM*EROM*) flashrom=true 
					name_rom=${zipname#*FROM-} ; name_rom=${name_rom#*FROM}
					name_rom=${name_rom%-EROM*} ; name_rom=${name_rom%EROM*}
					romzip="$zipfolder/$name_rom"
					;; 
				   *) flashrom=false ;;
	esac
	case $zipname in 
		*INSLOT-A*) $flashrom && newslot="_a" || newslot="$slot_ab" ;; 
		*INSLOT-B*) $flashrom && newslot="_b" || newslot="$slot_ab" ;; 
		         *) newslot="$slot_ab" ;; 
	esac
	case $zipname in 
		*REFLASHREC*) $flashrom && reflashrec=true || reflashrec=false ;; 
				   *) reflashrec=false ;; 
	esac
	case $zipname in 
		*FREC*EREC*) flashrec=true  
					name_rec=${zipname#*FREC-} ; name_rec=${name_rec#*FREC}
					name_rec=${name_rec%-EREC*} ; name_rec=${name_rec%EREC*}
					reczip="$zipfolder/$name_rec"
					reflashrec=false
					;;
		   		   *) flashrec=false ;; 
	esac
	case $zipname in 
		*FKER*EKER*) flashker=true  
					name_ker=${zipname#*FKER-} ; name_ker=${name_ker#*FKER}
					name_ker=${name_ker%-EKER*} ; name_ker=${name_ker%EKER*}
					kerzip="$zipfolder/$name_ker"
					;;
		   		   *) flashker=false ;; 
	esac
	case $zipname in 
		*FMAGISK*EMAGISK*) flashmagisk=true 
							name_magisk=${zipname#*FMAGISK-} ; name_magisk=${name_magisk#*FMAGISK}
							name_magisk=${name_magisk%-EMAGISK*} ; name_magisk=${name_magisk%EMAGISK*}
							magiskzip="$zipfolder/$name_magisk"
							;; 
						 *) flashmagisk=false ;; 
	esac
	}
RUN_ARG_CHECK(){ 
	if ! $flashrom && ! $flashrec && ! $flashker && ! $reflashrec && ! $flashdfe && ! $flashrw ! $flashmagisk ; then 
		/tmp/bin/busybox unzip  -o "$arg3" "arguments.txt" -d /tmp
		zipname=$(cat /tmp/arguments.txt)
		if [[ -f /tmp/arguments.txt ]] && [[ -f $zipfolder/arguments.txt ]] ; then 
				arguments="/tmp/arguments.txt"
				RUN_READ_ARG
				sdf=$flashrec$flashrw$flashrom$flashdfe$flashmagisk$flashker$reflashrec

				arguments="$zipfolder/arguments.txt"
				RUN_READ_ARG
				sdd=$flashrec$flashrw$flashrom$flashdfe$flashmagisk$flashker$reflashrec

				if [[ $sdf == falsefalsefalsefalsefalsefalsefalse ]] && [[ $sdd == falsefalsefalsefalsefalsefalsefalse ]]
				then ui_print "  -  No arguments" ; RUN_ARG_EXAMPLE ; 
				elif [[ $sdf != falsefalsefalsefalsefalsefalsefalse ]] && [[ $sdd != falsefalsefalsefalsefalsefalsefalse ]]
				then ui_print "  -  Detected both arguments.txt, remove into .zip arguments.txt or out .zip " ; exit 49
				elif [[ $sdf != falsefalsefalsefalsefalsefalsefalse ]] && [[ $sdd == falsefalsefalsefalsefalsefalsefalse ]]
				then arguments="/tmp/arguments.txt" ; RUN_READ_ARG
				elif [[ $sdf == falsefalsefalsefalsefalsefalsefalse ]] && [[ $sdd != falsefalsefalsefalsefalsefalsefalse ]]
				then arguments="$zipfolder/arguments.txt"; RUN_READ_ARG ; fi

			
		elif [[ -f /tmp/arguments.txt ]] ; then 
			arguments="/tmp/arguments.txt"
			RUN_READ_ARG
		elif [[ -f $zipfolder/arguments.txt ]] ; then 
			arguments="$zipfolder/arguments.txt"
			RUN_READ_ARG
		fi
		RUN_ARG_CHECK_ZIP
		RUN_LOGO
		if ! $flashrom && ! $flashrec && ! $flashker && ! $reflashrec && ! $flashdfe && ! $flashrw ! $flashmagisk ; then 
			ui_print "  -  No arguments"
			ui_print "  - Copy .zip name in arguments.txt into .zip files or creat near .zip arguments.txt"
			exit 49
		fi
	else
		RUN_LOGO
	fi
	}





RUN_ARG_CHECK_ZIP ; ffss=$?
if [[ $ffss == "88" ]] ; then /tmp/bin/busybox unzip -o "$3" "arguments.txt" -d /tmp ; arguments="/tmp/arguments.txt" ; RUN_READ_ARG ; RUN_ARG_CHECK
elif [[  $ffss == "89" ]]; then arguments="$zipfolder/arguments.txt" ; RUN_READ_ARG ; RUN_ARG_CHECK
else RUN_ARG_CHECK
fi
if ( mountpoint -q /data/ ) ; then
	home="/sdcard/MFPAPP" 
else
	if ( mountpoint -q /usb_otg/ ) ; then 
		home="/usb_otg/MFPAPP" 
	else 
		ui_print "  -  Need OTG or mounted /data/" 
	fi
fi
rm -rf $home

if ( echo $( basename $romzip ) | grep "\(" ) || ( echo $( basename $romzip ) | grep "\)" ) ; then
	ui_print "  -  Remove \) or \( in rom name"
	exit 77
fi 

sm8250=false
mkdir -pv /tmp/bin
mkdir -pv /tmp/lib
mkdir -pv /tmp/twrp
/tmp/bin/busybox unzip -o "$arg3" -d /tmp/
chmod 777 /tmp/bin/*
chmod 777 /tmp/lib/*
find /tmp/bin/* -exec ln -s {} /system/bin \; 
export PATH=/tmp/bin:$PATH 
mkdir -pv $home ; mkdir -pv $home/payload
mkdir -pv $home/imgs ; mkdir -pv $home/super ; mkdir -pv $home/nonsuper 
mkdir -pv $home/boot ; mkdir -pv $home/fw ; mkdir -pv $home/newdat
LPDUMP="$home/lpdump.txt"
lpdump --slot=$newslot >> $LPDUMP




RUN_FINAL(){
	$flashker && RUN_FLASH_KERNEL
	if [ $newslot == $slot_ab ] ; then
		avbctl --force disable-verity 
		avbctl --force disable-verification
	else
		dd if=/dev/block/by-name/vbmeta$newslot of=/dev/block/by-name/vbmeta$slot_ab
		dd if=/dev/block/by-name/vbmeta_system$newslot of=/dev/block/by-name/vbmeta_system$slot_ab
		avbctl --force disable-verity 
		avbctl --force disable-verification
		dd if=/dev/block/by-name/vbmeta$slot_ab of=/dev/block/by-name/vbmeta$newslot
		dd if=/dev/block/by-name/vbmeta_system$slot_ab of=/dev/block/by-name/vbmeta_system$newslot
	fi
	ddd=$( avbctl get-verification )
	ddf=$( avbctl get-verity )
	ddd="${ddd%"$slot_ab"*}${newslot}."
	ddf="${ddf%"$slot_ab"*}${newslot}."
	ui_print "  -  $ddf"
	ui_print "  -  $ddd"
	if [ $newslot == "_a" ] ; then

		bootctl set-active-boot-slot 0

	else 
		bootctl set-active-boot-slot 1
	fi
	if $flashdfe ; then 
			ui_print "  -------******!!!!!!!!!!!!!!!!!!!!******------"
			ui_print "  ---***|      Comlite decryption!      |***---"
			ui_print "  ---*If you are encrypted, you need to do**---"
			ui_print "  ---***|          Format data          |***---"
			ui_print "  -If you Decrypted and change the ROM, after--"
			ui_print "  -flashing the new ROM, you need to flash the-"
			ui_print "  ----DFE again, you are also advised to do*---"
			ui_print "  ---***|           Wipe Data           |***---"
			ui_print "  --If you are upgrading the ROM you need to---"
			ui_print "  ---***|       flash the DFE again     |***---"
			ui_print "  ------******!!!!!!!!!!!!!!!!!!!!******-------"
	fi
	rm -rf $home
	exit 0 


	}
RUN_DFE(){
	ui_print "  -  Starting DFE patch"
	sm8250=false
	size_c=false
	path_to=$1
	RUN_CHECK_RW "$path_to/etc"
	if [[ $retpop == "40" ]] ; then
		ui_print "  -  Starting patching fstabes"
		for fstabes in $( find $path_to/etc/*fstab* ) ; do
			if ( grep "/userdata" $fstabes ) && ( grep "/metadata" $fstabes ) ; then 
				while (grep "fileencryption=" $fstabes) || (grep "forcefdeorfbe=" $fstabes) || (grep "encryptable=" $fstabes) \
	                || (grep "forceencrypt=" $fstabes) || (grep "metadata_encryption=" $fstabes) || (grep "keydirectory=" $fstabes) \
	                || (grep "avb=" $fstabes) || (grep "avb_keys=" $fstabes) ; do
	                k=$(cat $fstabes)
					for ffff in "fileencryption=" "forcefdeorfbe=" "encryptable=" "forceencrypt=" "metadata_encryption=" "keydirectory=" "avb=" "avb_keys="
	                do
	                    grep "$ffff" $fstabes && rem="${k#*"$ffff"}" && rem="${rem%%,*}" && rem="${ffff}${rem%%"$tabes"*}" || continue
	                    grep ",$rem" $fstabes && sed -i 's|,'$rem'||' $fstabes && size_c=true && ui_print "  -  Remove ${ffff%=*}" && "  -  Flag ${rem#*"$ffff"}" 
	                    grep "$rem" $fstabes && sed -i 's|'$rem'||' $fstabes && size_c=true && ui_print "  -  Remove ${ffff%=*}" && "  -  Flag ${rem#*"$ffff"}"
	                done 
				done
				grep "avb" $fstabes && sed -i 's|,avb||g' $fstabes && size_c=true && ui_print "  -  Remove avb"
                grep "quota" $fstabes && sed -i 's|,quota||g' $fstabes && size_c=true && ui_print "  -  Remove quota"
                grep "inlinecrypt" $fstabes && sed -i 's|,inlinecrypt||g' $fstabes && size_c=true && ui_print "  -  Remove inlinecrypt"
                grep "wrappedkey" $fstabes && sed -i 's|,wrappedkey||g' $fstabes && size_c=true && ui_print "  -  Remove weappedkey"
				if [[ $( stat -c%s $fstabes ) -ge 30 ]] && $size_c ; then 
					ui_print "  -  $(basename $fstabes): Has been succesfully patched"
					if [ $( basename $fstabes) == "fstab.sm8250" ] ; then 
	                    sm8250=true
	                fi
	            elif [[ $( stat -c%s $fstabes ) -ge 30 ]] && ! $size_c ; then 
	            	ui_print "  -  $( basename $fstabes ): Doesn't need patching"
	            	if [ $( basename $fstabes) == "fstab.sm8250" ] ; then 
	                    sm8250=true
	                fi
				else
					# Фстаб ушел в 0
					ui_print "  -  Something wrong: error 89"
					ui_print "  -  You need reflash rom"
					exit 89
				fi
			fi
		done
	else
		# тестовый файл не может быть записан
		ui_print "  -  Something wrong: error 87"
		return 87
	fi
	}
RUN_CHECK_RW(){
	echo "test test test TEST TESTR TEST" >> $1/test.txt
	if [[ $( stat -c%s $1/test.txt ) -ge 6 ]] ; then
		rm -f $1/test.txt
		retpop=40
	else
		retpop=41
	fi

	}
RUN_RW(){

	umount /tmp/$( basename $1 )
    ui_print "  -  Give RW from $( basename $1 )"
    imgsize=$( stat -c%s $1 ) 
    new_size=$( calc "$imgsize*1.25/512" ) 
    echo "  -  $1 $imgsize $new_size"
    resize2fs -f $1 ${new_size}s
    e2fsck -y -E unshare_blocks $1
    resize2fs -f -M $1
    resize2fs -f -M $1

	}
RUN_RWS(){

	umount /tmp/$( basename $1 )
	psize=$2
    imgsize=$( stat -c%s $1 ) 
    new_size=$( calc "($imgsize+$2)/512" )
    echo "  -  $1 $imgsize $new_size"
    resize2fs -f $1 ${new_size}s

	}
RUN_ALL_RW(){

	ui_print "  -  Give RW for all partition"
    for img_rw in vendor system_ext product system ; do
    	[[ -f $home/imgs/$img_rw$newslot.img ]] && RUN_RW "$home/imgs/$img_rw$newslot.img"
    done
    Ss=$( grep -F -m 1 "Size:" $LPDUMP | awk '{print $2}' )
    vs=$( stat -c%s $home/imgs/vendor$newslot.img )
    ss=$( stat -c%s $home/imgs/system$newslot.img )
    if [ -f $home/imgs/product$newslot.img ] ; then 
        ps=$(stat -c%s $home/imgs/product$newslot.img)
        psf=true
    else
        psf=false 
        ui_print "  -  Non product" && ps=0
    fi
    if [ -f $home/imgs/system_ext$newslot.img ] ; then 
        sss=$(stat -c%s $home/imgs/system_ext$newslot.img)
        sssf=true
    else 
        sssf=false
        ui_print "  -  Non system_ext" && sss=0
    fi
    if [ -f $home/imgs/odm$newslot.img ] ; then 
        odms=$(stat -c%s $home/imgs/odm$newslot.img)
    else ui_print "  -  Non odm" && odms=0
    fi

    echo "  -  $Ss $vs $ss $ps $sss $odms"
    ssfree=$( calc "$Ss-$vs-8194304-$odms-$sss-$ss-$ps" )
    tfs=$( expr $ssfree / 1024 )
    echo "  -  $ssfree $tfs"
    if [ $tfs -gt 1 ] ; then
        if $psf && $sssf ; then
        	ui_print "  -  Full complect"
            nss=$( calc "$ssfree/3" )
            nvs=$( calc "($ssfree-$nss)/3" )
            nps=$( calc "($ssfree-$nss-$nvs)/2" )
            nsss=$( calc "$ssfree-$nss-$nvs-$nps" )
        fi
        if ! $psf && $sssf ; then
        	ui_print "  -  NON product"
            nss=$( calc "$ssfree/3" )
            nvs=$( calc "($ssfree-$nss)/2" )
            nsss=$( calc "$ssfree-$nss-$nvs" )
        fi
        if $psf && ! $sssf ; then
        	ui_print "  - NON system_ext"
            nss=$( calc "$ssfree/3" )
            nvs=$( calc "($ssfree-$nss)/2" )
            nps=$( calc "$ssfree-$nss-$nvs" )
        fi
        if ! $psf && ! $sssf ; then 
        	ui_print "  -  NON product and system_ext"
            nss=$( calc "$ssfree/2" )
            nvs=$( calc "$ssfree-$nss" )
        fi
        echo "  -  $nss $nvs $nps $nsss"
        RUN_RWS "$home/imgs/system$newslot.img" "$nss" 
        RUN_RWS "$home/imgs/vendor$newslot.img" "$nvs"
        $psf && RUN_RWS "$home/imgs/product$newslot.img" "$nps"
        $sssf && RUN_RWS "$home/imgs/system_ext$newslot.img" "$nsss"
    else 
        ui_print "  -  Unable to expand memory, super will be built with old parameters"

    fi
	}
RUN_MOUNT_IMG(){
	mountimg=$1
    mountimgN=$(basename ${mountimg%.img*})
    mkdir -pv /tmp/$mountimgN
    ( mountpoint -q /tmp/$mountimgN ) && umount /tmp/$mountimgN
    while (( ${count:=0} < 6 )) ; do
        (( count++ ))
        mount $mountimg /tmp/$mountimgN
        ( mountpoint -q /tmp/$mountimgN/ ) && break
    done

    if ( mountpoint -q /tmp/$mountimgN/ )
        then 
        	ui_print "  -  $mountimgN image has temporarily been mounted" 
        	retpop=40
        else 
        	retpop=41
    fi

	}
RUN_RW_LITE(){
    e2fsck -f /dev/block/mapper/$1
    blockdev --setrw /dev/block//mapper/$1
    e2fsck -E unshare_blocks -y -f /dev/block/mapper/$1
    resize2fs /dev/block/mapper/$1
	}
RUN_MAGISK_MODULE(){




	#########################################################
	RUN_START_MAGISK(){
		umask 022

		OUTFD=$2
		APK="$3"
		COMMONDIR=$INSTALLER/assets
		CHROMEDIR=$INSTALLER/assets/chromeos

		if [ ! -f $COMMONDIR/util_functions.sh ]; then
		  echo "! Unable to extract zip file!"
		  exit 1
		fi
		sed -i 's|ui_print "- |ui_print "  -  |g' $COMMONDIR/util_functions.sh
		sed -i 's|ui_print "- |ui_print "  -  |g' $COMMONDIR/boot_patch.sh
		sed -i 's|ui_print "$bar"|ui_print "     $bar"|g' $COMMONDIR/util_functions.sh
		sed -i 's|unzip|/tmp/bin/busybox unzip|g' $COMMONDIR/util_functions.sh
		
		. $COMMONDIR/util_functions.sh



		############
		# Detection
		############

		get_flags
		BOOTIMAGE="/dev/block/by-name/boot$newslot"
		ui_print "  -  Target image: $BOOTIMAGE"

		# Detect version and architecture
		api_level_arch_detect

		[ $API -lt 21 ] && abort "! Magisk only support Android 5.0 and above"

		ui_print "  -  Device platform: $ABI"

		if echo $MAGISK_VER | grep -q '\.'; then
		  PRETTY_VER=$MAGISK_VER
		else
		  PRETTY_VER="$MAGISK_VER($MAGISK_VER_CODE)"
		fi
		print_title " -  Magisk $PRETTY_VER Installer"

		# Detect version and architecture
		api_level_arch_detect

		[ $API -lt 21 ] && abort "! Magisk only support Android 5.0 and above"

		ui_print "  -  Device platform: $ABI"

		BINDIR=$INSTALLER/lib/$ABI
		cd $BINDIR
		for file in lib*.so; do mv "$file" "${file:3:${#file}-6}"; done
		cd /
		cp -af $INSTALLER/lib/$ABI32/libmagisk32.so $BINDIR/magisk32 2>/dev/null
		cp -af $CHROMEDIR/. $BINDIR/chromeos
		chmod -R 755 $BINDIR

		# Check if system root is installed and remove
		$BOOTMODE || remove_system_su

		##############
		# Environment
		##############

		ui_print "  -  Constructing environment"

		# Copy required files
		rm -rf $MAGISKBIN/* 2>/dev/null
		mkdir -p $MAGISKBIN 2>/dev/null
		cp -af $BINDIR/. $COMMONDIR/. $BBBIN $MAGISKBIN
		chmod -R 755 $MAGISKBIN

		# # addon.d
		# if [ -d /system/addon.d ]; then
		#   ui_print "- Adding addon.d survival script"
		#   blockdev --setrw /dev/block/mapper/system$SLOT 2>/dev/null
		#   mount -o rw,remount /system || mount -o rw,remount /
		#   ADDOND=/system/addon.d/99-magisk.sh
		#   cp -af $COMMONDIR/addon.d.sh $ADDOND
		#   chmod 755 $ADDOND
		# fi

		##################
		# Image Patching
		##################

		install_magisk

		# Cleanups
		$BOOTMODE || recovery_cleanup
		rm -rf $TMPDIR

		ui_print "  -  Done"
		}

	TMPDIR=/dev/tmp
	rm -rf $TMPDIR
	mkdir -p $TMPDIR 2>/dev/null

	export BBBIN=$TMPDIR/busybox
	for arch in "x86_64" "x86" "arm64-v8a" "armeabi-v7a"; do
	  /tmp/bin/busybox unzip -o "$magiskzip" "lib/$arch/libbusybox.so" -d $TMPDIR >&2
	  libpath="$TMPDIR/lib/$arch/libbusybox.so"
	  chmod 755 $libpath
	  if [ -x $libpath ] && $libpath >/dev/null 2>&1; then
	    mv -f $libpath $BBBIN
	    break
	  fi
	done
	$BBBIN rm -rf $TMPDIR/lib

	export INSTALLER=$TMPDIR/install
	$BBBIN mkdir -p $INSTALLER
	$BBBIN unzip -o "$3" "assets/*" "lib/*" "META-INF/com/google/*" -x "lib/*/libbusybox.so" -d $INSTALLER >&2
	export ASH_STANDALONE=1
	RUN_START_MAGISK $1 $2 "$magiskzip"


	
	}
RUN_MAGISK(){
	ui_print "  -  Starting magisk patch"
	if [[ -f $magiskzip ]] ; then 
		7za e "$magiskzip" -o/tmp/bin/ "*update-binary" -y -r -mmt8
		if [[ $newslot == $slot_ab ]] ; then 
		RUN_MAGISK_MODULE "$arg1" "$arg2" "$magiskzip"
		else
		RUN_MAGISK_MODULE "$arg1" "$arg2" "$magiskzip"
		dd if=/dev/block/by-name/boot$slot_ab of=/dev/block/by-name/boot$newslot
		fi
	else ui_print "  -  $magiskzip not finded"
	fi
	}
RUN_RECOVERY_REFLASH(){
	ui_print "  -  Starting recovery reflash"
	mkdir -pv /tmp/bin/twrp/
	mv /tmp/bin/twrp.img /tmp/bin/twrp/twrp.img
	dd if=/dev/block/by-name/boot$1 of=/tmp/bin/boot.img
	cd /tmp/bin ; magiskboot unpack boot.img
	rm -f ramdisk.cpio
	cd /tmp/bin/twrp ; magiskboot unpack twrp.img
	mv ramdisk.cpio /tmp/bin/
	cd /tmp/bin/
	cpio ramdisk.cpio sha1
	magiskboot repack boot.img
	dd if=/tmp/bin/new-boot.img of=/dev/block/by-name/boot$1
	rm -rf "twrp" "ramdisk*" "*.img" "kernel*"
	}
RUN_RECOVERY_FLASH(){
	ui_print "  -  Starting recovery Flashing $( basename $reczip )"
	if ( find $reczip ) ; then 
		case $reczip in
			*.img) 
			cp $reczip /tmp/bin/twrp.img
				;;
			*.zip) 
			cp $reczip /tmp/rec.zip
			reczip="/tmp/rec.zip"
			7za e "$reczip" -o/tmp/bin/ "recovery.img" -y -r -mmt8
			mv /tmp/bin/recovery.img /tmp/bin/twrp.img
			;;
		esac
		mkdir -pv /tmp/bin/twrp
		mv /tmp/bin/twrp.img /tmp/bin/twrp/twrp.img
 		dd if=/dev/block/by-name/boot$1 of=/tmp/bin/boot.img
 		cd /tmp/bin ; magiskboot unpack boot.img
 		rm -f ramdisk.cpio
 		cd /tmp/bin/twrp ; magiskboot unpack twrp.img
 		mv /tmp/bin/twrp/ramdisk.cpio /tmp/bin/ramdisk.cpio
 		cd /tmp/bin/ 
 		cpio ramdisk.cpio sha1
 		magiskboot repack boot.img
 		dd if=/tmp/bin/new-boot.img of=/dev/block/by-name/boot$1
 		rm -rf "twrp" "ramdisk*" "*.img" "kernel*"
 		retpop=40
 	else
 		ui_print "  -  $reczip not finded"
 		retpop=41
	fi
	}	
RUN_CHECK_ROM(){
	if [[ $( /tmp/bin/toybox df $home | awk ' NR==2 { if ($4 > 25843545) print "1" }' ) == "1" ]] ; then 
		ui_print "  -  Size normal"
	else
		ui_print "  -  Not enough free space"
		ui_print "  -  You have $( calc ""$(/tmp/bin/toybox df $home | awk ' NR==2 { print $4 }' )"/1024/1024" )GB"
		ui_print "  -  Need 24gb free space"
		exit 101
	fi
    if find $romzip ; then
        ui_print "  -  $romzip find"
        if $( 7za l "$romzip" | grep -q payload.bin ) ; then 
            ui_print "  -  Detected payload.bin"
            if [[ $( stat -c%s $romzip ) -ge 3221225472 ]] ; then
            return 55
        	else
        	return 51
        	fi

        elif $( 7za l "$romzip" | grep -q super.img ) && $( 7za l "$romzip" | grep -q system.img ) && $( 7za l "$romzip" | grep -q vendor.img ); then
            ui_print "  -  Detected fastboot rom"
            return 52
        elif $( 7za l "$romzip" | grep -q super.img ); then
            ui_print "  -  Detected fastboot with super.img rom"
            return 53
        elif $( 7za l "$romzip" | grep -q system.img ) && $( 7za l "$romzip" | grep -q vendor.img ); then
            ui_print "  -  Detected fastboot rom"
            return 52
        elif $( 7za l "$romzip" | grep -q ".new.dat" ) ; then 
        	mkdir -pv $home/newdatsuper
        	ui_print "  -  Detected miui style"
        	7za e "$romzip" -o$home/newdatsuper/ "updater-script" -y -r -mmt8
        	if ( grep "/super" $home/newdatsuper/updater-script | grep block_image_update ) ; then
        		ui_print "  -  Detected miui style rom with super"
        		r=$( grep "/super" $home/newdatsuper/updater-script | grep block_image_update )
        		r=${r#*package_extract_file} ; r${r%||*}
        		r=$( echo $r | awk '{ print $2 }' )
        		r=${r#*\"} ; r=${r%\"*}
        		return 56
        	elif $( 7za l "$romzip" | grep -q system.new.dat ) || $( 7za l "$romzip" | grep -q system.new.dat.br ); then
	            ui_print "  -  Detected miui style rom with part"
	            return 54 
	        fi
        fi
    else 
        ui_print "  -  $romzip not find"
        exit 105
    fi

	}
RUN_SINGL_STRUCTURES(){
	ui_print "  -  Starting SINGL STRUCTURES"
	ui_print "  -  Unpack $romzip"
	if [[ $1 == "54" ]] ; then 
		7za e "$romzip" -o$home/newdat/ "*.new.dat*" -y -r -mmt8
		7za e "$romzip" -o$home/newdat/ "*.transfer.list" -y -r -mmt8
		7za e "$romzip" -o$home/newdat/ "*.img" -y -r -mmt8
		for fwimgs in $( find $home/newdat/*.img ) ; do
	        mv $fwimgs $home/fw/
	    done
	    for imgs in $( find $home/newdat/*new.dat.br ) ; do
	    	ui_print "  -  Convert $( basename $imgs )"
	        brotli -df $imgs -o ${imgs%.br*} && rm -f $imgs
	    done
	    for imgs in $( find $home/newdat/*new.dat ) ; do
	    	ui_print "  -  Convert $( basename $imgs )"
	        sdat2img ${imgs%.new.dat*}.transfer.list $imgs ${imgs%.new.dat*}$newslot.img
	    done
	    for cust in $( find $home/newdat/cust*.img); do
	    	mv $cust $home/fw/cust.img
	    done
		for imgs in $( find $home/newdat/*.img ) ; do
	        mv $imgs $home/imgs/
	    done
	    rm -f $home/newdat/*
	elif [[ $1 == "56" ]] ; then 
		7za e "$romzip" -o$home/newdatsuper/ "*.new.dat*" -y -r -mmt8
		7za e "$romzip" -o$home/newdatsuper/ "*.transfer.list" -y -r -mmt8
		7za e "$romzip" -o$home/newdatsuper/ "*.img" -y -r -mmt8
		for fwimgs in $( find $home/newdatsuper/*.img ) ; do
	        mv $fwimgs $home/fw/
	    done
	    for imgs in $( find $home/newdatsuper/*new.dat.br ) ; do
	    	ui_print "  -  Convert $( basename $imgs )"
	        brotli -df $imgs -o ${imgs%.br*} && rm -f $imgs
	    done
	    for imgs in $( find $home/newdatsuper/*new.dat ) ; do
	    	ui_print "  -  Convert $( basename $imgs )"
	        sdat2img ${imgs%.new.dat*}.transfer.list $imgs ${imgs%.new.dat*}$newslot.img
	    done
	    mv $home/newdatsuper/${r%.new.dat*}$newslot.img $home/newdatsuper/super.img
	    for cust in $( find $home/newdatsuper/cust*.img); do
	    	mv $cust $home/fw/cust.img
	    done
	    if find $home/newdatsuper/super.img ; then
	    	if ( file $home/newdatsuper/super.img | grep -q sparse ) ; then 
			    simg2img $home/newdatsuper/super.img $home/newdatsuper/super.row.img
			    rm $home/newdatsuper/super.img
			    mv $home/newdatsuper/super.row.img $home/newdatsuper/super.img
		    fi
		    lpunpack $home/newdatsuper/super.img $home/newdatsuper/
		    for imgs in system_ext_a system_a vendor_a product_a odm_a ; do
		        for imgsp in $( find $home/newdatsuper/$imgs.img ) ; do 
			        if [[ $( stat -c%s $imgsp ) -ge 50 ]] ; then
			            mv $imgsp $home/imgs/${imgs%_*}$newslot.img
			        else
			            rm -f $imgsp
			        fi
		        done
		    done
		    rm $home/newdatsuper/super.img
		else
			ui_print "  -  Something wrong: error 62"
			exit 62
		fi
	    rm -f $home/newdatsuper/*
	elif [[ $1 == "53" ]] ; then
		7za e "$romzip" -o$home/super/ "*.img" -y -r -mmt8
	    if ( file $home/super/super.img | grep -q sparse ) ; then 
		    simg2img $home/super/super.img $home/super/super.row.img
		    rm $home/super/super.img
		    mv $home/super/super.row.img $home/super/super.img
	    fi
	    lpunpack $home/super/super.img $home/super/
	    for imgs in system_ext_a system_a vendor_a product_a odm_a ; do
	        for imgsp in $( find $home/super/$imgs*.img ) ; do 
	        if [[ $( stat -c%s $imgsp ) -ge 50 ]] ; then
	            mv $imgsp $home/imgs/${imgs%_*}$newslot.img
	        else
	            rm -f $imgsp
	        fi
	        done
	    done
	    rm $home/super/super.img
	    for fwimgs in $( find $home/super/*.img ) ; do
	        mv $fwimgs $home/fw/
	    done
	elif [[ $1 == "52" ]] ; then 
		7za e "$romzip" -o$home/nonsuper/ "*.img" -y -r -mmt8
		for bootimgs in "vendor_boot" "boot" ; do  
	        bootimgsp=$( find $home/nonsuper/$bootimgs*.img )
	        mv $bootimgsp $home/fw/
	    done
	    for imgs in system_ext vendor system product odm ; do
	        imgsp=$( find $home/nonsuper/$imgs* )
	        mv $imgsp $home/imgs/${imgs}${newslot}.img
	    done
	    for fwimgs in $( find $home/nonsuper/*.img ) ; do
	        mv $fwimgs $home/fw/
	    done
	    rm -f $home/fw/super*.img
	elif [[ $1 == "51" ]] ; then 
		pydump -c 8 -o $home/payload/ "$romzip"
	    for bootimgs in vendor_boot boot ; do  
	        bootimgsp=$( find $home/payload/$bootimgs*.img )
	        mv $bootimgsp $home/fw/
	    done
	    for imgs in system_ext system vendor product odm ; do

	        imgsp=$( find $home/payload/$imgs*.img )
	        ui_print "  -  Move $imgsp"
	        mv $imgsp $home/imgs/${imgs}$newslot.img
	    done
	    for fwimgs in $( find $home/payload/*.img ) ; do
	        mv $fwimgs $home/fw/
	    done
	elif [[ $1 == "55" ]] ; then 
		7za e "$romzip" -o$home/ "payload.bin" -y -r -mmt8
		pydump -c 8 -o $home/payload/ "$home/payload.bin"
		rm -f $home/payload.bin
	    for bootimgs in vendor_boot boot ; do  
	        bootimgsp=$( find $home/payload/$bootimgs*.img )
	        mv $bootimgsp $home/fw/
	    done
	    for imgs in system_ext system vendor product odm ; do

	        imgsp=$( find $home/payload/$imgs*.img )
	        ui_print "  -  Move $imgsp"
	        mv $imgsp $home/imgs/${imgs}$newslot.img
	    done
	    for fwimgs in $( find $home/payload/*.img ) ; do
	        mv $fwimgs $home/fw/
	    done
	fi
	}
RUN_MAKE_SUPER(){
	ui_print "  -  Make new super partition"
    ms=$(grep -F "Metadata max size:" $LPDUMP | awk '{print $4}')
    mslot=$(grep -F "Metadata slot count:" $LPDUMP | awk '{print $NF}')
    Ss=$( grep -F "Size:" $LPDUMP | awk '{print $2}' )
    gp=$( grep -F "part" $LPDUMP | grep -F "Name" | grep -F "$newslot"| awk '{print $NF}' )
    partadd=$(  for img in $(find $home/imgs/*.img) ; do
                    bimg=$(basename ${img})
                    part_ab=${bimg//.*}
                    img_size=$(stat -c%s $img)
                    [ -z $gp ] && echo -n "--partition ${part_ab}:none:$img_size:qti_dynamic_partitions$newslot "
                    [ -z $gp ] || echo -n "--partition ${part_ab}:none:$img_size:$gp "
                    echo -n "--image ${part_ab}=$img "
                done
         )
    [ -z $gp ] || echo "--metadata-size $ms --super-name super --sparse --metadata-slots $mslot --device super:$Ss --group $gp:$Ss $partadd --output $home/newsuper.img" >> $home/argslp.txt
    [ -z $gp ] && echo "--metadata-size $ms --super-name super --sparse --metadata-slots $mslot --device super:$Ss --group qti_dynamic_partitions$newslot:$Ss $partadd --output $home/newsuper.img" >> $home/argslp.txt
    ui_print "  -  Creation of newsuper.img. For OTG process very long 40-50 minutes. Please wait..."
    lpmake $(cat "$home/argslp.txt") && retpop=40 || retpop=41

	}
RUN_INIT_PATCH(){
	gon=false
    finit=$(grep -n -x "on init" $1/system/etc/init/hw/init.rc | awk '{print int($1)}')
    RUN_CHECK_RW $1/system/etc 
    if [[ $retpop == 40 ]] ; then
        floop=false 
        while [ $floop == false ] ; do
            finit=$( expr $finit + 1 )
            r=$(head -n$finit $1/system/etc/init/hw/init.rc | tail -n1)
            [[ -z $r ]] && break
        done 
        grep "ro.crypto.state" $1/system/etc/init/hw/init.rc && sed -i '/ro.crypto.state/d' $1/system/etc/init/hw/init.rc && gon=true && sed -i "${finit}i \    setprop ro.crypto.state encrypted" $1/system/etc/init/hw/init.rc
        ! $gon && sed -i "${finit}i \   setprop ro.crypto.state encrypted" $1/system/etc/init/hw/init.rc
    else
        ui_print "  -  Something wrong: error 12"
        exit 12
    fi
	}
RUN_BOOT_PATCH(){
	ui_print "  -  Starting boot patching"
	dd if=/dev/block/by-name/boot$1 of=/tmp/bin/boot.img
	cd /tmp/bin
	magiskboot unpack boot.img
	magiskboot cpio ramdisk.cpio patch
	for dt in dtb kernel_dtb extra kernel; do
		[ -f $dt ] && magiskboot dtb $dt patch 
	done
	if [ -f kernel ]; then
		magiskboot hexpatch kernel 49010054011440B93FA00F71E9000054010840B93FA00F7189000054001840B91FA00F7188010054 A1020054011440B93FA00F7140020054010840B93FA00F71E0010054001840B91FA00F7181010054
		magiskboot hexpatch kernel 821B8012 E2FF8F12
		magiskboot hexpatch kernel 736B69705F696E697472616D667300 77616E745F696E697472616D667300
	fi
	magiskboot repack boot.img
	dd if=/tmp/bin/new-boot.img of=/dev/block/by-name/boot$1
	rm -rf "twrp" "ramdisk*" "*.img" "kernel*"

	}
RUN_VENDORBOOT_PATCH(){
	ui_print "  -  Starting vendor_boot patch"
	mkdir -pv /tmp/bin/vendor_boot
	dd if=/dev/block/by-name/vendor_boot$newslot of=/tmp/bin/vendor_boot/boot.img
	cd /tmp/bin/vendor_boot
	magiskboot unpack -h boot.img
	grep "androidboot.verifiedbootstate=green" header && sed -i 's|androidboot.verifiedbootstate=green||' header
	grep "androidboot.vbmeta.device_state=locked" header && sed -i 's|androidboot.vbmeta.device_state=locked||' header
	magiskboot repack boot.img vendor_boot.img
	dd if=/tmp/bin/vendor_boot/vendor_boot.img of=/dev/block/by-name/vendor_boot$newslot
	cd /tmp/bin
	rm -rf "vendor_boot"

	}
RUN_FW_FLASH(){
	ui_print "  -  Starting Flashing FW"
	for fw in $( find $home/fw/*img $home/boot/*img ) ; do
        fwname=$( basename ${fw%.img*} )
        ui_print "  -  Flashing $fwname"
        dd if=$fw of=/dev/block/by-name/$fwname$newslot
    done
    }
RUN_RECOVERY_FLASH_SM8250(){
	ui_print "  -  Starting Flashing twrp vashy for SM8250"
	dd if=/dev/block/by-name/boot$1 of=/tmp/bin/boot.img
	cd /tmp/bin ; magiskboot unpack boot.img
	rm -f ramdisk.cpio
	cp /tmp/twrp/twrp.cpio /tmp/bin/ramdisk.cpio
	cd /tmp/bin/ 
	cpio ramdisk.cpio sha1
	magiskboot repack boot.img
	dd if=/tmp/bin/new-boot.img of=/dev/block/by-name/boot$1
	rm -rf "twrp" "ramdisk*" "*.img" "kernel*"
	}
RUN_DUMP_PART(){
	if [ $(/tmp/bin/toybox df $home | awk ' NR==2 { if ($4 > 15843545) print "1" }') == "1" ] ; then 
		ui_print "  -  Size normal"
	else
		ui_print "  -  Not enough free space"
		ui_print "  -  you have $( calc "$(/tmp/bin/toybox df $home | awk ' NR==2 { print $4 }' )/1024/1024" )GB"
		ui_print "  -  Need 24gb free space"
		exit 101
	fi
	ui_print "  -  Starting dumping partition"
	for part in $(find /dev/block/mapper/*$newslot) ; do
		ui_print "  -  Dumpimg $(basename $part)" 
		dd if=$part of=$home/imgs/$(basename $part).img
	done
	}
RUN_DFE_RW_IN_SUPER(){

		if $flashrw ; then
			RUN_ALL_RW
		fi
		if $flashdfe ; then
		echo "  -  test1"
		RUN_MOUNT_IMG "$home/imgs/vendor$newslot.img"
		if [[ $retpop == 41 ]] ; then
			echo "  -  test2"
			RUN_RW "$home/imgs/vendor$newslot.img" 
			RUN_RWS "$home/imgs/vendor$newslot.img" "20971520" 
			RUN_RWS "$home/imgs/vendor$newslot.img" "20971520" 
			RUN_MOUNT_IMG "$home/imgs/vendor$newslot.img" 
			if [[ $retpop == 41 ]] ; then 
				ui_print "  -  Something wrong: error 10"
				exit 10
			else
				echo "  -  test3"
				RUN_CHECK_RW "/tmp/$mountimgN/etc"
				if [[ $retpop == 41 ]] ; then
					echo "  -  test4"
					RUN_RW "$home/imgs/vendor$newslot.img" 
					RUN_RWS "$home/imgs/vendor$newslot.img" "20971520" 
					RUN_RWS "$home/imgs/vendor$newslot.img" "20971520" 
					RUN_MOUNT_IMG "$home/imgs/vendor$newslot.img"
					[[ $retpop == 40 ]] && RUN_CHECK_RW "/tmp/$mountimgN/etc"
					[[ $retpop == 40 ]] && RUN_DFE "/tmp/$mountimgN" && umount "/tmp/$mountimgN" || exit 98
				else
					echo "  -  test5"
					RUN_DFE "/tmp/$mountimgN"
					umount "/tmp/$mountimgN"
				fi
			fi
		elif [[ $retpop == 40 ]]; then
			echo "  -  test11"
			RUN_CHECK_RW "/tmp/$mountimgN/etc"
			if [[ $retpop == 41 ]] ; then
				echo "  -  test12"
				RUN_RW "$home/imgs/vendor$newslot.img" 
				RUN_RWS "$home/imgs/vendor$newslot.img" "20971520" 
				RUN_MOUNT_IMG "$home/imgs/vendor$newslot.img"
				[[ $retpop == 40 ]] && RUN_CHECK_RW "/tmp/$mountimgN/etc"
				[[ $retpop == 40 ]] && RUN_DFE "/tmp/$mountimgN" && umount "/tmp/$mountimgN" || exit 39
			else
				echo "  -  test13"
				RUN_DFE "/tmp/$mountimgN"
				umount "/tmp/$mountimgN"
			fi
		fi 
	fi

	if $sm8250 ; then
		RUN_MOUNT_IMG "$home/imgs/system$newslot.img"
		if [[ $retpop == "41" ]] ; then
			RUN_RW "$home/imgs/system$newslot.img" 
			RUN_RWS "$home/imgs/system$newslot.img" "20971520" 
			RUN_MOUNT_IMG "$home/imgs/system$newslot.img" 
			if [[ $retpop == "41" ]] ; then 
				ui_print "  -  Something wrong: error 111"
				exit 111
			else
				RUN_CHECK_RW "/tmp/$mountimgN/etc"
				if [[ $retpop == "41" ]] ; then
					RUN_RW "$home/imgs/system$newslot.img" 
					RUN_RWS "$home/imgs/system$newslot.img" "20971520" 
					RUN_MOUNT_IMG "$home/imgs/system$newslot.img"
					[[ $retpop == 40 ]] && RUN_INIT_PATCH "/tmp/$mountimgN" && umount "/tmp/$mountimgN" || exit 21
				else
					RUN_INIT_PATCH "/tmp/$mountimgN"
					umount "/tmp/$mountimgN"
				fi
			fi
		else
			RUN_CHECK_RW "/tmp/$mountimgN/etc"
			if [[ $retpop == "41" ]] ; then
				RUN_RW "$home/imgs/system$newslot.img" 
				RUN_RWS "$home/imgs/system$newslot.img" "20971520" 
				RUN_MOUNT_IMG "$home/imgs/system$newslot.img"
				[[ $retpop == 40 ]] && RUN_INIT_PATCH "/tmp/$mountimgN" && umount "/tmp/$mountimgN" || exit 23
			else
				RUN_INIT_PATCH "/tmp/$mountimgN"
				umount "/tmp/$mountimgN"
			fi
		fi 
	fi
	RUN_MAKE_SUPER
	return 40
	

	}
RUN_CHECK_PART(){
	if [[ -f $home/imgs/product$newslot.img ]] && [[ -f $home/imgs/system_ext$newslot.img ]] ; then 
		ui_print "  -  Fine part"
	else
		flashmagisk=false
	fi

	}
RUN_FLASH_KERNEL(){
	if find $kerzip ; then
		ui_print "  -  Flashing Kernel $( basename $kerzip )"
		mkdir -pv /tmp/bin/ker
		cp $kerzip /tmp/kernel.zip
		kerzip="/tmp/kernel.zip"
		7za e "$kerzip" -o/tmp/bin/ker "update-binary" -y -r -mmt8
		if [[ $slot_ab == $newslot ]] ; then
			sh /tmp/bin/ker/update-binary $arg1 $arg2 "$kerzip"
		else
			dd if=/dev/block/by-name/boot$newslot of=/dev/block/by-name/boot$slot_ab
			sh /tmp/bin/ker/update-binary $arg1 $arg2 "$kerzip"
			dd if=/dev/block/by-name/boot$slot_ab of=/dev/block/by-name/boot$newslot
		fi
	else
		ui_print "  -  $kerzip not finded"
	fi
	}
RUN_POST_PATCH(){
	if $flashrec ; then 
		if $sm8250 ; then 
			ui_print "  -  Patching flash recvoery for SM8250"
			RUN_RECOVERY_FLASH_SM8250 $newslot
		else 
			ui_print "  -  Patching flash recvoery"
			RUN_RECOVERY_FLASH $newslot
		fi
	fi

	if $flashmagisk ; then
		ui_print "  -  Patching boot with magisk"
		RUN_MAGISK
	else
		ui_print "  -  Patching boot"
		RUN_BOOT_PATCH $newslot
	fi
	ui_print "  -  Patching vendor_boot"
	RUN_VENDORBOOT_PATCH $newslot
	}
RUN_SIMG2IMG(){

	for img in $( find $home/imgs/*.img $home/fw/*.img ); do
		if  [[ $( file $img | grep "sparse" ) ]] ; then
			ui_print "  -  simg2img $( basename $img )"
			simg2img $img $( dirname $img )/$( basename ${img%.img*} ).raw.img
			rm -f $img ; mv $( dirname $img )/$( basename ${img%.img*} ).raw.img $img
		fi
	done

	}

RUN_MOUNT_PART(){
	umount /$1
	mount /$1
	mount -o rw,remount /$1
	}
if $flashrom ; then 

	RUN_CHECK_ROM
	RUN_SINGL_STRUCTURES $?
	RUN_SIMG2IMG 
	RUN_DFE_RW_IN_SUPER
	RUN_CHECK_PART

	if [[ $retpop == 40 ]] ; then
		$reflashrec && dd if=/dev/block/by-name/boot$slot_ab of=/tmp/bin/twrp.img
		RUN_FW_FLASH 
		if $flashrec ; then 
			if $sm8250 ; then 
				RUN_RECOVERY_FLASH_SM8250 $newslot
			else 
				RUN_RECOVERY_FLASH $newslot
			fi
		elif $reflashrec ; then
			if $sm8250 ; then 
				RUN_RECOVERY_FLASH_SM8250 $newslot
			else 
				RUN_RECOVERY_REFLASH $newslot
			fi
		fi

		if $flashmagisk ; then
			RUN_MAGISK
		else
			RUN_BOOT_PATCH $newslot
		fi
		RUN_VENDORBOOT_PATCH $newslot


		ui_print "  -  Flashing new super partition. For OTG process very long 40-50 minutes. Please wait..."
		simg2img $home/newsuper.img /dev/block/by-name/super
		RUN_FINAL
	else
		ui_print "  -  Something went wrong. Send recovery.log to developer on TG @LeeGarChat"
		exit 123
	fi
elif ! $flashrom ; then

	RUN_MOUNT_PART vendor
	if $flashrw ; then 
		RUN_DUMP_PART
		RUN_DFE_RW_IN_SUPER
		if [[ $retpop == 40 ]] ; then
			RUN_POST_PATCH
			ui_print "  -  Flashing new super partition. For OTG process very long 40-50 minutes. Please wait..."
			simg2img $home/newsuper.img /dev/block/by-name/super
			RUN_FINAL
		elif [[ $retpop == 41 ]] ; then
			ui_print "  -  Something went wrong. Send recovery.log to developer on TG @LeeGarChat"
			exit 124
		fi
	elif ! $flashrw ; then 
		RUN_MOUNT_PART vendor
		RUN_CHECK_RW "/vendor/etc"
		if [[ $retpop == 40 ]] ; then
			ui_print "  -  ss12"
			RUN_MOUNT_PART vendor
			RUN_DFE "/vendor"
		elif [[ $retpop == 41 ]] ; then
			ui_print "  -  ss13"
			RUN_RW_LITE "vendor$newslot"
			RUN_MOUNT_PART vendor 
			RUN_CHECK_RW "/vendor/etc"
			if [[ $retpop == 40 ]] ; then 
				RUN_MOUNT_PART vendor
				ui_print "  -  ss14"
				RUN_DFE "/vendor"
			elif [[ $retpop == 41 ]] ; then
				RUN_DUMP_PART
				RUN_DFE_RW_IN_SUPER
				if [[ $retpop == 40 ]] ; then
					RUN_POST_PATCH
					ui_print "  -  Flashing new super partition. For OTG process very long 40-50 minutes. Please wait..."
					simg2img $home/newsuper.img /dev/block/by-name/super
					RUN_FINAL
				elif [[ $retpop == 41 ]] ; then
					ui_print "  -  Something went wrong. Send recovery.log to developer on TG @LeeGarChat"
					exit 125
				fi
			fi
		elif [[ $retpop == 40 ]] ; then 
		if $sm8250 ; then 
			RUN_MOUNT_PART system_root
			RUN_CHECK_RW "/system_root/system/etc"
			if [[ $retpop == 40 ]] ; then 
				RUN_MOUNT_PART system_root
				RUN_INIT_PATCH "/system_root"
			else 
				ui_print "  -  Something wrong: error 41"
				exit 126
			fi
			RUN_POST_PATCH
			RUN_FINAL
		fi

		fi
	fi

	

fi


exit 177