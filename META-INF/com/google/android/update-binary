#!/sbin/sh

#Объявление основых переменных и постоянных функций
export OUTFD=$2

arg1=$1 ; arg2=$2 ; arg3=$3

ui_print(){ echo -e "ui_print $1" >> "/proc/self/fd/$arg2" ; }
progress(){ echo -e "progress $1 $2" >> "/proc/self/fd/$arg2" ; }
set_progress(){ echo -e "set_progress $1" >> "/proc/self/fd/$arg2" ; }
calc(){ awk 'BEGIN{ print int('$1') }' ; }
tabes="
"
MFPAPP="MFP-ALPHA-4.1.1"

zipname="$(basename "$arg3")" ; zipfolder="$(dirname "$arg3")"

mount /data
unzip -o "$arg3" "busybox" -d /tmp/bin/
chmod 777 /tmp/bin/busybox
mkdir -pv /tmp/bin
mkdir -pv /tmp/lib
mkdir -pv /tmp/twrp
/tmp/bin/busybox unzip -o "$arg3" -d /tmp/
chmod 777 /tmp/bin/*
chmod 777 /tmp/lib/*
find /tmp/bin/* -exec ln -s {} /system/bin \; 
export PATH=/tmp/bin:$PATH 
slot_num=$(bootctl get-current-slot) ; slot_ab=$(bootctl get-suffix $slot_num)
ui_print "-  $slot_num $slot_ab"
if ( /tmp/bin/toybox mountpoint -q /sdcard/ ) ; then
home="/sdcard/MFPAPP" 
ui_print "-  Home folder $home"
elif ( /tmp/bin/toybox mountpoint -q /data/ ) ; then
home="/data/media/0/MFPAPP"
ui_print "-  Home folder $home"
else
if ( /tmp/bin/toybox mountpoint -q /usb_otg/ ) ; then 
	home="/usb_otg/MFPAPP" 
	ui_print "-  Home folder $home"
else 
	ui_print "-  Need OTG or mounted /sdcard/ for stable working" 
	exit 66
fi
fi
rm -rf $home


sm8250=false ; extsuper=false
mkdir -pv $home ; mkdir -pv $home/payload
mkdir -pv $home/imgs ; mkdir -pv $home/super ; mkdir -pv $home/nonsuper 
mkdir -pv $home/newdatsuper ; mkdir -pv $home/fw ; mkdir -pv $home/newdat
n=1


RUN_READ_ARG(){
	for remove in $( grep "\"/storage/" $arguments ) ; do
		dod1=${remove#*\"} ; dod1=${dod1%\"*}
		dod2="/sdcard/"${dod#*/*/*/*/}""
		sed -i 's|'$dod1'|'$dod2'|' $arguments
	done
	for remove in $( grep "\"/mnt/" $arguments ) ; do
		dod1=${remove#*\"} ; dod1=${dod1%\"*}
		dod2="/usb_otg/"${dod#*/*/*/*/}""
		sed -i 's|'$dod1'|'$dod2'|' $arguments
	done

	if ( grep "INSTALL SLOT" "$arguments" | grep -i "_a" ) ; then
		$flashrom && newslot="_a" || newslot="$slot_ab"
	elif ( grep "INSTALL SLOT" "$arguments" | grep -i "_b" ) ; then
		$flashrom && newslot="_b" || newslot="$slot_ab"
	else 
		newslot="$slot_ab" ; fi

	( grep "MAKERW" "$arguments" | grep -i "yes" ) && flashrw=true || flashrw=false

	( grep "DFE" "$arguments" | grep -i "yes" ) && flashdfe=true || flashdfe=false

	if ( grep "FLASH ROM" "$arguments" | grep -i "yes" ) ; then
		name_rom=$(grep -i "path rom" "$arguments")
		name_rom=${name_rom#*\"} ; name_rom=${name_rom%\"*}
		if [[ -z $name_rom ]] ; then flashrom=false ; else
			if ( echo $name_rom | grep "/" ) ; then romzip=$name_rom
			else romzip="$zipfolder/$name_rom" ; fi
			if [[ -f $romzip ]] ; then flashrom=true
			else ui_print "-  Not find $romzip" ; exit 147 ; fi ; fi
	else flashrom=false ; fi

	if ( grep "FLASH ADDITIONAL ZIPS" "$arguments" | grep -i "yes" ) ; then
		for list in $( grep -i "Path additional zips" "$arguments" ) ; do 
			list=$( echo "$list" | grep -q "\.zip" && echo $list ; echo "$list" | grep -q "\.apk" && echo $list ) 
			name_ADDzip=${list#*\"} ; name_ADDzip=${name_ADDzip%%\"*}
			if [[ -z $name_ADDzip ]] ; then 
				continue 
			else
				ui_print "-  $name_ADDzip"
				if ( echo $name_ADDzip | grep "/" ) ; then 
					ADDzip=$name_ADDzip
				else 
					ADDzip="$zipfolder/$name_ADDzip" 
				fi
				if [[ -f $ADDzip ]] ; then 
					listADDzip="$listADDzip\n$ADDzip"
				else ui_print "-  Not find $ADDzip" 
					exit 149 
				fi 
			fi
		done
		if ( echo -e "$listADDzip" | grep "/" ) ; then flashADDzip=true ; else flashADDzip=false ; fi
	else flashADDzip=false ; fi

	if ( grep "FLASH RECOVERY" "$arguments" | grep -i "yes" ) ; then
		name_rec=$(grep -i "path recovery" "$arguments")
		name_rec=${name_rec#*\"} ; name_rec=${name_rec%\"*}
		if [[ -z $name_rec ]] ; then flashrec=false ; else
			if ( echo $name_rec | grep "/" ) ; then reczip=$name_rec
			else reczip="$zipfolder/$name_rec" ; fi
			if [[ -f $reczip ]] ; then flashrec=true
			else ui_print "-  Not find $reczip" ; exit 140 ; fi ; fi
	else flashrec=false ; fi

	if ( grep "REFLASH RECOVERY" "$arguments" | grep -i "yes" ) ; then 
		$flashrom && reflashrec=true || reflashrec=false
	else reflashrec=false ; fi

	}

RUN_ARG_CHECK(){ 
	if ! $flashrom && ! $flashrec && ! $flashdfe && ! $flashrw ; then 
		ui_print "-  No arguments"
		ui_print "- Copy .zip name in arguments.txt into .zip files or creat near .zip arguments.txt"
		exit 49
	else
		RUN_LOGO
	fi
	}

RUN_LOGO(){
	ui_print " "
	ui_print "------******!!!!!!!!!!!!!!!!!!!!******-------"
	ui_print " "
	ui_print "-  $MFPAPP"
	ui_print "-  by @LeeGarChat"
	ui_print "-  Telegram group @PocoF3DFE"
	ui_print "-  Thanks for @ErenMetesarr"
	ui_print " "
	ui_print "------******!!!!!!!!!!!!!!!!!!!!******-------"
	ui_print " "
	ui_print "-  MAKERW: $( $flashrw && echo "YES" || echo NO )"
	ui_print "-  DFE: $( $flashdfe && echo "YES" || echo NO )"
	ui_print "-  INSLOT-A/B: $newslot"
	ui_print "-  REFLASH RECOVERY: $( $reflashrec && echo "YES" || echo NO )"
	ui_print "-  FLASH RECOVERY: $( $flashrec && echo "YES" || echo NO )"
	ui_print "-  $( basename $reczip )"
	ui_print "-  FLASH ROM: $( $flashrom && echo "YES" || echo NO )"
	ui_print "-  $( basename $romzip )"
	ui_print " "
	ui_print "------******!!!!!!!!!!!!!!!!!!!!******-------"
	ui_print " "
	}

RUN_MOUNT_SUPER(){ bakblock="/dev/block/backup/"

	case $1 in
		--mount)
	umount /system_root ; umount /vendor ; umount /product ; umount /system_ext ; umount /odm
	block_system=$( grep "/system_root" /etc/fstab | awk '{ print $1 }' )
	block_system_ext=$( grep "/system_ext" /etc/fstab | awk '{ print $1 }' )
	block_vendor=$( grep "/vendor" /etc/fstab | awk '{ print $1 }' )
	block_product=$( grep "/product" /etc/fstab | awk '{ print $1 }' )
	block_odm=$( grep "/odm" /etc/fstab | awk '{ print $1 }' )

	for img in $block_system $block_system_ext $block_vendor $block_product $block_odm ; do 
		mv $img $bakblock
	done
	loop_system=$( losetup -f )
	losetup $loop_system $home/imgs/system$newslot.img
	mv $loop_system $block_system
	loop_vendor=$( losetup -f )
	losetup $loop_vendor $home/imgs/vendor$newslot.img
	mv $loop_vendor $block_vendor
	loop_system_ext=$( losetup -f )
	losetup $loop_system_ext $home/imgs/system_ext$newslot.img
	mv $loop_system_ext $block_system_ext
	loop_product=$( losetup -f )
	losetup $loop_product $home/imgs/product$newslot.img
	mv $loop_product $block_product
	loop_odm=$( losetup -f )
	losetup $loop_odm $home/imgs/odm$newslot.img
	mv $loop_odm $block_odm
	dd if=/dev/block/by-name$slot_ab if=/tmp/bin/twrp.img
	for fwimg in $( find $home/fw/*.img ) ; do
		[[ -d /dev/block/backup ]] || mkdir /dev/block/backup
		bakblock="/dev/block/backup/"
		naked_name=$( basename ${fwimg%.img*} )
		for block in $( find /dev/block/by-name/${naked_name}$slot_ab ) ; do
			if ( file $block | grep "symbolic link" ) ; then
				linkblock=$( readlink $block )
				dd if=$linkblock of=${bakblock}$( basename $linkblock )
				dd if=$fwimg of=$linkblock
				echo "${linkblock}LOLLOLLOLFACK$fwimg" >> $home/list_block.txt
			fi
		done
	done
	extsuper=true
			;;
			--umount ) 
			if [[ -z $block_system ]] ; then 
				ui_print " Something wrong: error 221"
				exit 221
			else
				umount /system_root ; umount /vendor ; umount /product ; umount /system_ext ; umount /odm
				mv $block_odm $loop_odm
				mv $block_system $loop_system
				mv $block_product $loop_product
				mv $block_system_ext $loop_system_ext
				mv $block_vendor $loop_vendor
				for img in $block_system $block_system_ext $block_vendor $block_product $block_odm ; do 
					mv $bakblock$( basename $img ) $img
				done
			fi
			for fwimg in $( cat $home/list_block.txt ) ; do
				bakblock="/dev/block/backup/"
				rm -f ${fwimg#*LOLLOLLOLFACK}
				dd if="${fwimg%LOLLOLLOLFACK*}" of="${fwimg#*LOLLOLLOLFACK}"
				dd if=$bakblock$( basename ${fwimg%LOLLOLLOLFACK*} ) of="${fwimg%LOLLOLLOLFACK*}"
			done
			extsuper=false
			;;	 
	esac
	}

RUN_MAKE_SUPER(){
	ui_print "-  Make new super partition"
    ms=$(grep -F "Metadata max size:" $LPDUMP | awk '{print $4}')
    mslot=$(grep -F "Metadata slot count:" $LPDUMP | awk '{print $NF}')
    Ss=$( grep -F "Size:" $LPDUMP | awk '{print $2}' )
    gp=$( grep -F "part" $LPDUMP | grep -F "Name" | grep -F "$newslot"| awk '{print $NF}' )
    partadd=$(  for img in $(find $home/imgs/*.img) ; do
                    bimg=$(basename ${img})
                    part_ab=${bimg//.*}
                    img_size=$(stat -c%s $img)
                    [ -z $gp ] && echo -n "--partition ${part_ab}:none:$img_size:qti_dynamic_partitions$newslot "
                    [ -z $gp ] || echo -n "--partition ${part_ab}:none:$img_size:$gp "
                    echo -n "--image ${part_ab}=$img "
                done
         )
    [ -z $gp ] || echo "--metadata-size $ms --super-name super --sparse --metadata-slots $mslot --device super:$Ss --group $gp:$Ss $partadd --output $home/newsuper.img" >> $home/argslp.txt
    [ -z $gp ] && echo "--metadata-size $ms --super-name super --sparse --metadata-slots $mslot --device super:$Ss --group qti_dynamic_partitions$newslot:$Ss $partadd --output $home/newsuper.img" >> $home/argslp.txt
    ui_print "-  Creation of newsuper.img. For OTG process very long 40-50 minutes. Please wait..."
    lpmake $(cat "$home/argslp.txt") && retpop=40 || retpop=41

	}	

RUN_SINGL_STRUCTURES(){
	ui_print "-  Starting SINGL STRUCTURES"
	ui_print "-  Unpack $romzip"
	if [[ $1 == "54" ]] ; then 
		7za e "$romzip" -o$home/newdat/ "*.new.dat*" -y -r -mmt8
		7za e "$romzip" -o$home/newdat/ "*.transfer.list" -y -r -mmt8
		7za e "$romzip" -o$home/newdat/ "*.img" -y -r -mmt8
		for fwimgs in $( find $home/newdat/*.img ) ; do
	        mv $fwimgs $home/fw/
	    done
	    for imgs in $( find $home/newdat/*new.dat.br ) ; do
	    	ui_print "-  Convert $( basename $imgs )"
	        brotli -df $imgs -o ${imgs%.br*} && rm -f $imgs
	    done
	    for imgs in $( find $home/newdat/*new.dat ) ; do
	    	ui_print "-  Convert $( basename $imgs )"
	        sdat2img ${imgs%.new.dat*}.transfer.list $imgs ${imgs%.new.dat*}$newslot.img
	    done
	    for cust in $( find $home/newdat/cust*.img); do
	    	mv $cust $home/fw/cust.img
	    done
		for imgs in $( find $home/newdat/*.img ) ; do
	        mv $imgs $home/imgs/
	    done
	    rm -f $home/newdat/*
	elif [[ $1 == "56" ]] ; then 
		7za e "$romzip" -o$home/newdatsuper/ "*.new.dat*" -y -r -mmt8
		7za e "$romzip" -o$home/newdatsuper/ "*.transfer.list" -y -r -mmt8
		7za e "$romzip" -o$home/newdatsuper/ "*.img" -y -r -mmt8
		for fwimgs in $( find $home/newdatsuper/*.img ) ; do
	        mv $fwimgs $home/fw/
	    done
	    for imgs in $( find $home/newdatsuper/*new.dat.br ) ; do
	    	ui_print "-  Convert $( basename $imgs )"
	        brotli -df $imgs -o ${imgs%.br*} && rm -f $imgs
	    done
	    for imgs in $( find $home/newdatsuper/*new.dat ) ; do
	    	ui_print "-  Convert $( basename $imgs )"
	        sdat2img ${imgs%.new.dat*}.transfer.list $imgs ${imgs%.new.dat*}$newslot.img
	    done
	    mv $home/newdatsuper/${r%.new.dat*}$newslot.img $home/newdatsuper/super.img
	    for cust in $( find $home/newdatsuper/cust*.img); do
	    	mv $cust $home/fw/cust.img
	    done
	    if [[ -f $home/newdatsuper/super.img ]] ; then
	    	if ( file $home/newdatsuper/super.img | grep -q sparse ) ; then 
			    simg2img $home/newdatsuper/super.img $home/newdatsuper/super.row.img
			    rm $home/newdatsuper/super.img
			    mv $home/newdatsuper/super.row.img $home/newdatsuper/super.img
		    fi
		    lpunpack $home/newdatsuper/super.img $home/newdatsuper/
		    for imgs in system_ext_a system_a vendor_a product_a odm_a ; do
		        for imgsp in $( find $home/newdatsuper/$imgs.img ) ; do 
			        if [[ $( stat -c%s $imgsp ) -ge 50 ]] ; then
			            mv $imgsp $home/imgs/${imgs%_*}$newslot.img
			        else
			            rm -f $imgsp
			        fi
		        done
		    done
		    rm $home/newdatsuper/super.img
		else
			ui_print "-  Something wrong: error 62"
			exit 62
		fi
	    rm -f $home/newdatsuper/*
	elif [[ $1 == "53" ]] ; then
		7za e "$romzip" -o$home/super/ "*.img" -y -r -mmt8
	    if ( file $home/super/super.img | grep -q sparse ) ; then 
		    simg2img $home/super/super.img $home/super/super.row.img
		    rm $home/super/super.img
		    mv $home/super/super.row.img $home/super/super.img
	    fi
	    lpunpack $home/super/super.img $home/super/
	    for imgs in system_ext_a system_a vendor_a product_a odm_a ; do
	        for imgsp in $( find $home/super/$imgs*.img ) ; do 
	        if [[ $( stat -c%s $imgsp ) -ge 50 ]] ; then
	            mv $imgsp $home/imgs/${imgs%_*}$newslot.img
	        else
	            rm -f $imgsp
	        fi
	        done
	    done
	    rm $home/super/super.img
	    for fwimgs in $( find $home/super/*.img ) ; do
	        mv $fwimgs $home/fw/
	    done
	elif [[ $1 == "52" ]] ; then 
		7za e "$romzip" -o$home/nonsuper/ "*.img" -y -r -mmt8
		for bootimgs in "vendor_boot" "boot" ; do  
	        bootimgsp=$( find $home/nonsuper/$bootimgs*.img )
	        mv $bootimgsp $home/fw/
	    done
	    for imgs in system_ext vendor system product odm ; do
	        imgsp=$( find $home/nonsuper/$imgs* )
	        mv $imgsp $home/imgs/${imgs}${newslot}.img
	    done
	    for fwimgs in $( find $home/nonsuper/*.img ) ; do
	        mv $fwimgs $home/fw/
	    done
	    rm -f $home/fw/super*.img
	elif [[ $1 == "51" ]] ; then 
		pydump -c 8 -o $home/payload/ "$romzip"
	    for bootimgs in vendor_boot boot ; do  
	        bootimgsp=$( find $home/payload/$bootimgs*.img )
	        mv $bootimgsp $home/fw/
	    done
	    for imgs in system_ext system vendor product odm ; do

	        imgsp=$( find $home/payload/$imgs*.img )
	        ui_print "-  Move $imgsp"
	        mv $imgsp $home/imgs/${imgs}$newslot.img
	    done
	    for fwimgs in $( find $home/payload/*.img ) ; do
	        mv $fwimgs $home/fw/
	    done
	elif [[ $1 == "55" ]] ; then 
		7za e "$romzip" -o$home/ "payload.bin" -y -r -mmt8
		pydump -c 8 -o $home/payload/ "$home/payload.bin"
		rm -f $home/payload.bin
	    for bootimgs in vendor_boot boot ; do  
	        bootimgsp=$( find $home/payload/$bootimgs*.img )
	        mv $bootimgsp $home/fw/
	    done
	    for imgs in system_ext system vendor product odm ; do
	        imgsp=$( find $home/payload/$imgs*.img )
	        ui_print "-  Move $imgsp"
	        mv $imgsp $home/imgs/${imgs}$newslot.img
	    done
	    for fwimgs in $( find $home/payload/*.img ) ; do
	        mv $fwimgs $home/fw/
	    done
	fi
	for img in $( find $home/imgs/*.img $home/fw/*.img ); do
		if  [[ $( file $img | grep "sparse" ) ]] ; then
			ui_print "-  simg2img $( basename $img )"
			simg2img $img $( dirname $img )/$( basename ${img%.img*} ).raw.img
			rm -f $img ; mv $( dirname $img )/$( basename ${img%.img*} ).raw.img $img
		fi
	done
	}

RUN_DUMP_PART(){
	if [ $(/tmp/bin/toybox df $home | awk ' NR==2 { if ($4 > 15843545) print "1" }') == "1" ] ; then 
		ui_print "-  Size normal: $( calc "$( /tmp/bin/toybox df $home | awk ' NR==2 { print $4 }' )/1024" )MB"
	else
		ui_print "-  Not enough free space"
		ui_print "-  you have $( calc "$( /tmp/bin/toybox df $home | awk ' NR==2 { print $4 }' )/1024/1024" )GB"
		ui_print "-  Need 15~gb free space"
		exit 101
	fi
	ui_print "-  Starting dumping partition"
	for part in $(find /dev/block/mapper/*$newslot) ; do
		ui_print "-  Dumpimg $(basename $part)" 
		dd if=$part of=$home/imgs/$(basename $part).img
	done
	}

RUN_ALL_MAUNT(){
	for mnt in vendor system_root odm system_ext product ; do
		case "$1" in
			--mount )
				umount /$mnt
				mount /$mnt
				mount -o rw,remount /$mnt
				;;
			--umount )
				umount /$mnt
				;;
		esac
	done
	}

RUN_CHECK_ROM(){
		if [[ $( /tmp/bin/toybox df $home | awk ' NR==2 { if ($4 > 25843545) print "1" }' ) == "1" ]] ; then
			ui_print "-  Size normal: $( calc "$( /tmp/bin/toybox df $home | awk ' NR==2 { print $4 }' )/1024" )MB"
		else
			ui_print "-  Not enough free space"
			ui_print "-  You have $( calc ""$( /tmp/bin/toybox df $home | awk ' NR==2 { print $4 }' )"/1024/1024" )GB"
			ui_print "-  Need 24gb free space"
			exit 101
		fi
		if [[ -f $romzip ]] ; then
		    ui_print "-  $romzip find"
		    if $( 7za l "$romzip" | grep -q payload.bin ) ; then 
		        ui_print "-  Detected payload.bin"
		        if [[ $( stat -c%s $romzip ) -ge 3221225472 ]] ; then
		        return 55
		    	else
		    	return 51
		    	fi

		    elif $( 7za l "$romzip" | grep -q super.img ) && $( 7za l "$romzip" | grep -q system.img ) && $( 7za l "$romzip" | grep -q vendor.img ); then
		        ui_print "-  Detected fastboot rom"
		        return 52
		    elif $( 7za l "$romzip" | grep -q super.img ); then
		        ui_print "-  Detected fastboot with super.img rom"
		        return 53
		    elif $( 7za l "$romzip" | grep -q system.img ) && $( 7za l "$romzip" | grep -q vendor.img ); then
		        ui_print "-  Detected fastboot rom"
		        return 52
		    elif $( 7za l "$romzip" | grep -q ".new.dat" ) ; then 
		    	mkdir -pv $home/newdatsuper
		    	ui_print "-  Detected miui style"
		    	7za e "$romzip" -o$home/newdatsuper/ "updater-script" -y -r -mmt8
		    	if ( grep "/super" $home/newdatsuper/updater-script | grep block_image_update ) ; then
		    		ui_print "-  Detected miui style rom with super"
		    		r=$( grep "/super" $home/newdatsuper/updater-script | grep block_image_update )
		    		r=${r#*package_extract_file} ; r${r%||*}
		    		r=$( echo $r | awk '{ print $2 }' )
		    		r=${r#*\"} ; r=${r%\"*}
		    		return 56
		    	elif $( 7za l "$romzip" | grep -q system.new.dat ) || $( 7za l "$romzip" | grep -q system.new.dat.br ); then
		            ui_print "-  Detected miui style rom with part"
		            return 54 
		        fi
		    fi
		else 
		    ui_print "-  $romzip not find"
		    exit 105
		fi
	}

RUN_DFE(){
	ui_print "-  Starting DFE patch"
	sm8250=false
	size_c=false
	path_to=$1
	ui_print "-  Starting patching fstabes"
	for fstabes in $( find $path_to/etc/*fstab* ) ; do
		if ( grep "/userdata" $fstabes ) && ( grep "/metadata" $fstabes ) ; then 
			ui_print "-  $( basename $fstabes )"
			while (grep "fileencryption=" $fstabes) || (grep "forcefdeorfbe=" $fstabes) || (grep "encryptable=" $fstabes) \
                || (grep "forceencrypt=" $fstabes) || (grep "metadata_encryption=" $fstabes) || (grep "keydirectory=" $fstabes) \
                || (grep "avb=" $fstabes) || (grep "avb_keys=" $fstabes) ; do
                k=$(cat $fstabes)
				for ffff in "fileencryption=" "forcefdeorfbe=" "encryptable=" "forceencrypt=" "metadata_encryption=" "keydirectory=" "avb=" "avb_keys="
                do
                    grep "$ffff" $fstabes && rem="${k#*"$ffff"}" && rem="${rem%%,*}" && rem="${ffff}${rem%%"$tabes"*}" || continue
                    grep ",$rem" $fstabes && sed -i 's|,'$rem'||' $fstabes && size_c=true && ui_print "-  Flag ${rem#*"$ffff"}" 
                    grep "$rem" $fstabes && sed -i 's|'$rem'||' $fstabes && size_c=true && ui_print "-  Flag ${rem#*"$ffff"}"
                done 
			done
			grep "avb" $fstabes && sed -i 's|,avb||g' $fstabes && size_c=true && ui_print "-  Remove avb"
            grep "quota" $fstabes && sed -i 's|,quota||g' $fstabes && size_c=true && ui_print "-  Remove quota"
            grep "inlinecrypt" $fstabes && sed -i 's|,inlinecrypt||g' $fstabes && size_c=true && ui_print "-  Remove inlinecrypt"
            grep "wrappedkey" $fstabes && sed -i 's|,wrappedkey||g' $fstabes && size_c=true && ui_print "-  Remove weappedkey"
			if [[ $( stat -c%s $fstabes ) -ge 30 ]] && $size_c ; then 
				ui_print "-  $(basename $fstabes): Has been succesfully patched"
				if [ $( basename $fstabes) == "fstab.sm8250" ] ; then 
                    sm8250=true
                fi
            elif [[ $( stat -c%s $fstabes ) -ge 30 ]] && ! $size_c ; then 
            	ui_print "-  $( basename $fstabes ): Doesn't need patching"
            	if [ $( basename $fstabes) == "fstab.sm8250" ] ; then 
                    sm8250=true
                fi
			else
				# Фстаб ушел в 0
				ui_print "-  Something wrong: error 89"
				ui_print "-  You need reflash rom"
				exit 89
			fi
		fi
	done
	}

RUN_CHECK_RW(){
	for mnt in /system_root/system /vendor/etc ; do 
		echo "test test test TEST TESTR TEST" >> $mnt/test.txt
		if [[ $( stat -c%s $mnt/test.txt ) -ge 6 ]] ; then
			rm -f $mnt/test.txt
		else
			return 41
		fi
	done
	return 40
	}

RUN_RW(){
	asdf=$( basename $1 )
	umount /tmp/$( basename ${asdf%.img*} )
	imgsize=$( stat -c%s $1 ) 
	new_size=$( calc "$imgsize*1.25/512" ) 
	echo "  -  $1 $imgsize $new_size"
	resize2fs -f $1 ${new_size}s
	e2fsck -y -E unshare_blocks $1
	resize2fs -f -M $1
	resize2fs -f -M $1

	}

RUN_RWS(){
	asdf=$( basename $1 )
	umount /tmp/$( basename $1 )
	psize=$2
	imgsize=$( stat -c%s $1 ) 
	new_size=$( calc "($imgsize+$2)/512" )
	ui_print "-  Give RW "${asdf%"$newslot".img*}" - size: $(calc "($imgsize+$2)/1024/1024")MB. Free: $(calc "$2/1024/1024")MB"
	echo "  -  $1 $imgsize $new_size"
	resize2fs -f $1 ${new_size}s

	}

RUN_RECOVERY_REFLASH(){
	ui_print "-  Starting recovery reflash"
	mkdir -pv /tmp/bin/twrp/
	mv /tmp/bin/twrp.img /tmp/bin/twrp/twrp.img
	dd if=/dev/block/by-name/boot$1 of=/tmp/bin/boot.img
	cd /tmp/bin ; magiskboot unpack boot.img
	rm -f ramdisk.cpio
	cd /tmp/bin/twrp ; magiskboot unpack twrp.img
	mv ramdisk.cpio /tmp/bin/
	cd /tmp/bin/
	cpio ramdisk.cpio sha1
	magiskboot repack boot.img
	dd if=/tmp/bin/new-boot.img of=/dev/block/by-name/boot$1
	rm -rf "twrp" "ramdisk*" "*.img" "kernel*"
	}

RUN_FINAL(){
	if [ $newslot == $slot_ab ] ; then
		avbctl --force disable-verity 
		avbctl --force disable-verification
	else
		dd if=/dev/block/by-name/vbmeta$newslot of=/dev/block/by-name/vbmeta$slot_ab
		dd if=/dev/block/by-name/vbmeta_system$newslot of=/dev/block/by-name/vbmeta_system$slot_ab
		avbctl --force disable-verity 
		avbctl --force disable-verification
		dd if=/dev/block/by-name/vbmeta$slot_ab of=/dev/block/by-name/vbmeta$newslot
		dd if=/dev/block/by-name/vbmeta_system$slot_ab of=/dev/block/by-name/vbmeta_system$newslot
	fi
	ddd=$( avbctl get-verification )
	ddf=$( avbctl get-verity )
	ddd="${ddd%"$slot_ab"*}${newslot}."
	ddf="${ddf%"$slot_ab"*}${newslot}."
	ui_print "-  $ddf"
	ui_print "-  $ddd"
	if [ $newslot == "_a" ] ; then

		bootctl set-active-boot-slot 0

	else 
		bootctl set-active-boot-slot 1
	fi
	if $flashdfe ; then 
			ui_print "-------******!!!!!!!!!!!!!!!!!!!!******------"
			ui_print "---***|      Comlite decryption!      |***---"
			ui_print "---*If you are encrypted, you need to do**---"
			ui_print "---***|          Format data          |***---"
			ui_print "-If you Decrypted and change the ROM, after--"
			ui_print "-flashing the new ROM, you need to flash the-"
			ui_print "----DFE again, you are also advised to do*---"
			ui_print "---***|           Wipe Data           |***---"
			ui_print "--If you are upgrading the ROM you need to---"
			ui_print "---***|       flash the DFE again     |***---"
			ui_print "------******!!!!!!!!!!!!!!!!!!!!******-------"
	fi
			ui_print  "------******!!!!!!!!!!!!!!!!!!!!******-------"
			ui_print  "------      Installing complited      -------"
			ui_print  "------******!!!!!!!!!!!!!!!!!!!!******-------"
	#rm -rf $home
	exit 0 
	}

RUN_ALL_RW(){
	ui_print "-  Give RW for all partition"
	for img_rw in vendor system_ext product system ; do
		[[ -f $home/imgs/$img_rw$newslot.img ]] && RUN_RW "$home/imgs/$img_rw$newslot.img"
	done
	Ss=$( grep -F -m 1 "Size:" $LPDUMP | awk '{print $2}' )
	vs=$( stat -c%s $home/imgs/vendor$newslot.img )
	ss=$( stat -c%s $home/imgs/system$newslot.img )
	if [ -f $home/imgs/product$newslot.img ] ; then 
	    ps=$(stat -c%s $home/imgs/product$newslot.img)
	    psf=true
	else
	    psf=false 
	    ui_print "-  Non product" && ps=0
	fi
	if [ -f $home/imgs/system_ext$newslot.img ] ; then 
	    sss=$(stat -c%s $home/imgs/system_ext$newslot.img)
	    sssf=true
	else 
	    sssf=false
	    ui_print "-  Non system_ext" && sss=0
	fi
	if [ -f $home/imgs/odm$newslot.img ] ; then 
	    odms=$(stat -c%s $home/imgs/odm$newslot.img)
	else ui_print "-  Non odm" && odms=0
	fi

	#ui_print "-  $Ss $vs $ss $ps $sss $odms"
	ssfree=$( calc "$Ss-$vs-8194304-$odms-$sss-$ss-$ps" )
	tfs=$( expr $ssfree / 1024 )
	echo "  -  $ssfree $tfs"
	if [ $tfs -gt 1 ] ; then
	    if $psf && $sssf ; then
	    	ui_print "-  Full complect"
	        nss=$( calc "$ssfree/3" )
	        nvs=$( calc "($ssfree-$nss)/3" )
	        nps=$( calc "($ssfree-$nss-$nvs)/2" )
	        nsss=$( calc "$ssfree-$nss-$nvs-$nps" )
	    fi
	    if ! $psf && $sssf ; then
	    	ui_print "-  NON product"
	        nss=$( calc "$ssfree/3" )
	        nvs=$( calc "($ssfree-$nss)/2" )
	        nsss=$( calc "$ssfree-$nss-$nvs" )
	    fi
	    if $psf && ! $sssf ; then
	    	ui_print "- NON system_ext"
	        nss=$( calc "$ssfree/3" )
	        nvs=$( calc "($ssfree-$nss)/2" )
	        nps=$( calc "$ssfree-$nss-$nvs" )
	    fi
	    if ! $psf && ! $sssf ; then 
	    	ui_print "-  NON product and system_ext"
	        nss=$( calc "$ssfree/2" )
	        nvs=$( calc "$ssfree-$nss" )
	    fi
	    echo "  -  $nss $nvs $nps $nsss"
	    RUN_RWS "$home/imgs/system$newslot.img" "$nss" 
	    RUN_RWS "$home/imgs/vendor$newslot.img" "$nvs"
	    $psf && RUN_RWS "$home/imgs/product$newslot.img" "$nps"
	    $sssf && RUN_RWS "$home/imgs/system_ext$newslot.img" "$nsss"
	else 
	    ui_print "-  Unable to expand memory, super will be built with old parameters"

	fi
	}

RUN_RECOVERY_FLASH(){
		ui_print "-  Starting recovery Flashing $( basename $reczip )"
		if [[ -f $reczip ]] ; then 
			case $reczip in
				*.img) 
				cp $reczip /tmp/bin/twrp.img
					;;
				*.zip) 
				cp $reczip /tmp/rec.zip
				reczip="/tmp/rec.zip"
				7za e "$reczip" -o/tmp/bin/ "recovery.img" -y -r -mmt8
				mv /tmp/bin/recovery.img /tmp/bin/twrp.img
				;;
			esac
			mkdir -pv /tmp/bin/twrp
			mv /tmp/bin/twrp.img /tmp/bin/twrp/twrp.img
			dd if=/dev/block/by-name/boot$slot_ab of=/tmp/bin/boot.img
			cd /tmp/bin ; magiskboot unpack boot.img
			rm -f ramdisk.cpio
			cd /tmp/bin/twrp ; magiskboot unpack twrp.img
			mv /tmp/bin/twrp/ramdisk.cpio /tmp/bin/ramdisk.cpio
			cd /tmp/bin/ 
			cpio ramdisk.cpio sha1
			magiskboot repack boot.img
			dd if=/tmp/bin/new-boot.img of=/dev/block/by-name/boot$slot_ab
			rm -rf "twrp" "ramdisk*" "*.img" "kernel*"
			retpop=40
		else
			ui_print "-  $reczip not finded"
			flashrec=false
			retpop=41
		fi
		}	

RUN_INIT_PATCH(){
	gon=false
	finit=$(grep -n -x "on init" $1/system/etc/init/hw/init.rc | awk '{print int($1)}')
	RUN_CHECK_RW $1/system/etc 
	if [[ $retpop == 40 ]] ; then
	    floop=false 
	    while [ $floop == false ] ; do
	        finit=$( expr $finit + 1 )
	        r=$(head -n$finit $1/system/etc/init/hw/init.rc | tail -n1)
	        [[ -z $r ]] && break
	    done 
	    grep "ro.crypto.state" $1/system/etc/init/hw/init.rc && sed -i '/ro.crypto.state/d' $1/system/etc/init/hw/init.rc && gon=true && sed -i "${finit}i \    setprop ro.crypto.state encrypted" $1/system/etc/init/hw/init.rc
	    ! $gon && sed -i "${finit}i \   setprop ro.crypto.state encrypted" $1/system/etc/init/hw/init.rc
	else
	    ui_print "-  Something wrong: error 12"
	    exit 12
	fi
	}

RUN_BOOT_PATCH(){
	ui_print "-  Starting boot patching"
	dd if=/dev/block/by-name/boot$1 of=/tmp/bin/boot.img
	cd /tmp/bin
	magiskboot unpack boot.img
	magiskboot cpio ramdisk.cpio patch
	for dt in dtb kernel_dtb extra kernel; do
		[ -f $dt ] && magiskboot dtb $dt patch 
	done
	if [ -f kernel ]; then
		magiskboot hexpatch kernel 49010054011440B93FA00F71E9000054010840B93FA00F7189000054001840B91FA00F7188010054 A1020054011440B93FA00F7140020054010840B93FA00F71E0010054001840B91FA00F7181010054
		magiskboot hexpatch kernel 821B8012 E2FF8F12
		magiskboot hexpatch kernel 736B69705F696E697472616D667300 77616E745F696E697472616D667300
	fi
	magiskboot repack boot.img
	dd if=/tmp/bin/new-boot.img of=/dev/block/by-name/boot$1
	rm -rf "twrp" "ramdisk*" "*.img" "kernel*"

	}

RUN_VENDORBOOT_PATCH(){
	ui_print "-  Starting vendor_boot patch"
	mkdir -pv /tmp/bin/vendor_boot
	dd if=/dev/block/by-name/vendor_boot$newslot of=/tmp/bin/vendor_boot/boot.img
	cd /tmp/bin/vendor_boot
	magiskboot unpack -h boot.img
	grep "androidboot.verifiedbootstate=green" header && sed -i 's|androidboot.verifiedbootstate=green||' header
	grep "androidboot.vbmeta.device_state=locked" header && sed -i 's|androidboot.vbmeta.device_state=locked||' header
	magiskboot repack boot.img vendor_boot.img
	dd if=/tmp/bin/vendor_boot/vendor_boot.img of=/dev/block/by-name/vendor_boot$newslot
	cd /tmp/bin
	rm -rf "vendor_boot"

	}

RUN_FW_FLASH(){
	ui_print "-  Starting Flashing FW"
	if $flashfw ; then 
		for fw in $( find $home/fw/*img $home/boot/*img ) ; do
		    fwname=$( basename ${fw%.img*} )
		    ui_print "-  Flashing inbuild $fwname"
		    dd if=$fw of=/dev/block/by-name/$fwname$newslot
		done
	fi
	}

RUN_RECOVERY_FLASH_SM8250(){
	ui_print "-  Starting Flashing twrp vashy for SM8250"
	dd if=/dev/block/by-name/boot$1 of=/tmp/bin/boot.img
	cd /tmp/bin ; magiskboot unpack boot.img
	rm -f ramdisk.cpio
	cp /tmp/twrp/twrp.cpio /tmp/bin/ramdisk.cpio
	cd /tmp/bin/ 
	cpio ramdisk.cpio sha1
	magiskboot repack boot.img
	dd if=/tmp/bin/new-boot.img of=/dev/block/by-name/boot$1
	rm -rf "twrp" "ramdisk*" "*.img" "kernel*"
	}

RUN_POST_PATCH(){
	if $flashrec && ! $reflashrec ; then 
		if $sm8250 ; then 
			ui_print "-  Patching flash recvoery for SM8250"
			RUN_RECOVERY_FLASH_SM8250 
		else 
			ui_print "-  Patching flash recvoery"
			RUN_RECOVERY_FLASH 
		fi
	elif ! $flashrec && $reflashrec ; then 
		if $sm8250 ; then 
			ui_print "-  Patching reflash recvoery for SM8250"
			RUN_RECOVERY_FLASH_SM8250 
		else 
			ui_print "-  Patching reflash recvoery"
			RUN_RECOVERY_REFLASH
		fi
	fi
	ui_print "-  Patching vendor_boot"
	RUN_VENDORBOOT_PATCH $newslot
	}

RUN_RW_LITE(){
	for mnt in vendor system odm system_ext product ; do
		e2fsck -f /dev/block/mapper/${mnt}$slot_ab
	    blockdev --setrw /dev/block/mapper/${mnt}$slot_ab
	    e2fsck -E unshare_blocks -y -f /dev/block/mapper/${mnt}$slot_ab
	    resize2fs /dev/block/mapper/${mnt}$slot_ab
	done 
	}

RUN_FLASH_ZIPS(){
	for install in $( echo -e "$listADDzip" ) ; do
		mkdir -pv /tmp/addzip/$( basename ${install%.zip*} )
		unzip -o "$install" "META-INF/com/google/android/update-binary" -d /tmp/addzip/$( basename ${install%.zip*} )/
		ui_print "************************************"		
		ui_print "************************************"
		ui_print "------------------------------------"
		ui_print "-  FLASHING $( basename $install )"
		ui_print "------------------------------------"
		ui_print "************************************"
		ui_print "************************************"
		chmod 777 /tmp/addzip/$( basename ${install%.zip*} )/META-INF/com/google/android/update-binary
		/tmp/addzip/$( basename ${install%.zip*} )/META-INF/com/google/android/update-binary $arg1 $arg2 "$install"		
	done
		ui_print "************************************"		
		ui_print "************************************"
		ui_print "------------------------------------"
		ui_print "-  Complect installing all additional zips "
		ui_print "************************************"		
		ui_print "************************************"
		ui_print "------------------------------------"
	}


case $zipname in
	*ARGOUT*)
		arguments=$zipfolder/arguments.txt
		;;
		   *)	
		unzip -o "$install" "arguments.txt" -d /tmp/lib/
		arguments=/tmp/lib/arguments.txt
		;;
esac

RUN_READ_ARG
RUN_ARG_CHECK

if ( echo $( basename $romzip ) | grep '(' ) || ( echo $( basename $romzip ) | grep ')' ) ; then
	ui_print "-  Remove \) or \( in rom name"
	exit 77
fi 
LPDUMP="$home/lpdump.txt"
lpdump --slot=$newslot >> $LPDUMP

if $flashrom ; then
	RUN_CHECK_ROM
	RUN_SINGL_STRUCTURES $?
	if $flashADDzip || $flashdfe || $flashrw ; then 
		RUN_ALL_RW
	fi
	RUN_ALL_MAUNT --umount
	RUN_MOUNT_SUPER --mount
fi
	
RUN_ALL_MAUNT --mount ; RUN_CHECK_RW ; perm=$? 
if [[ $perm == 41 ]] ; then 
	if ! $flashrom ; then 
		RUN_RW_LITE ; RUN_ALL_MAUNT --mount ; RUN_CHECK_RW ; permm=$? ; perm=$permm
	fi ; fi
if ( [[ $permm == 41 ]] && ! $flashrom ) || ( $flashrw && ! $flashrom ) ; then 
	RUN_ALL_MAUNT --umount
	RUN_DUMP_PART
	RUN_ALL_RW
	RUN_MOUNT_SUPER --mount
	RUN_ALL_MAUNT --mount
	RUN_CHECK_RW ; perm=$? 
	if [[ $perm == 41 ]] ; then 
		RUN_ALL_MAUNT --umount
		RUN_MOUNT_SUPER --umount
		ui_print "-  Something wrong: 21"
		exit 21
	fi ; fi
[[ -f /vendor/etc/fstab.sm8250 ]] && sm8250=true || sm8250=false

$flashdfe && RUN_DFE "/vendor"
$sm8250 && RUN_INIT_PATCH /system_root/system
RUN_POST_PATCH
$flashADDzip && RUN_FLASH_ZIPS
RUN_ALL_MAUNT --umount
RUN_MOUNT_SUPER --umount
if [[ $permm == 41 ]] || $flashrw || $flashrom ; then
	RUN_MAKE_SUPER
	if [[ $retpop == 40 ]] ; then 
		ui_print "-  Flashing new SUPER partition. wait..."
		simg2img $home/newsuper.img /dev/block/by-name/super
		RUN_FW_FLASH

	else
		ui_print "-  Something wrong: error 91"
		exit 91
	fi
fi
RUN_FINAL
exit 0